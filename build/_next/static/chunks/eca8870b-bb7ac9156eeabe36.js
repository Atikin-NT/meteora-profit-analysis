"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[237],{7615:function(e,t,i){i.d(t,{ZP:function(){return eP},xO:function(){return B}});var n,a,r,o,s,u=i(5914),m=i(7390),d=i(4777),l=i(3613),c=i(1236),p=i(7043),y=i(8467),g=i(8407),h=i(482),b=i(3550);i(1481);var w=i(5166),f=i(8764).Buffer,B={version:"0.6.0",name:"lb_clmm",constants:[{name:"BASIS_POINT_MAX",type:"i32",value:"10000"},{name:"MAX_BIN_PER_ARRAY",type:{defined:"usize"},value:"70"},{name:"MAX_BIN_PER_POSITION",type:{defined:"usize"},value:"70"},{name:"MIN_BIN_ID",type:"i32",value:"- 443636"},{name:"MAX_BIN_ID",type:"i32",value:"443636"},{name:"MAX_FEE_RATE",type:"u64",value:"100_000_000"},{name:"FEE_PRECISION",type:"u64",value:"1_000_000_000"},{name:"MAX_PROTOCOL_SHARE",type:"u16",value:"2_500"},{name:"HOST_FEE_BPS",type:"u16",value:"2_000"},{name:"NUM_REWARDS",type:{defined:"usize"},value:"2"},{name:"MIN_REWARD_DURATION",type:"u64",value:"1"},{name:"MAX_REWARD_DURATION",type:"u64",value:"31536000"},{name:"EXTENSION_BINARRAY_BITMAP_SIZE",type:{defined:"usize"},value:"12"},{name:"BIN_ARRAY_BITMAP_SIZE",type:"i32",value:"512"},{name:"MAX_REWARD_BIN_SPLIT",type:{defined:"usize"},value:"15"},{name:"BIN_ARRAY",type:"bytes",value:"[98, 105, 110, 95, 97, 114, 114, 97, 121]"},{name:"ORACLE",type:"bytes",value:"[111, 114, 97, 99, 108, 101]"},{name:"BIN_ARRAY_BITMAP_SEED",type:"bytes",value:"[98, 105, 116, 109, 97, 112]"},{name:"PRESET_PARAMETER",type:"bytes",value:"[112, 114, 101, 115, 101, 116, 95, 112, 97, 114, 97, 109, 101, 116, 101, 114]"},{name:"POSITION",type:"bytes",value:"[112, 111, 115, 105, 116, 105, 111, 110]"}],instructions:[{name:"initializeLbPair",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"tokenMintX",isMut:!1,isSigner:!1},{name:"tokenMintY",isMut:!1,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"oracle",isMut:!0,isSigner:!1},{name:"presetParameter",isMut:!1,isSigner:!1},{name:"funder",isMut:!0,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"activeId",type:"i32"},{name:"binStep",type:"u16"}]},{name:"initializePermissionLbPair",accounts:[{name:"base",isMut:!1,isSigner:!0},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"tokenMintX",isMut:!1,isSigner:!1},{name:"tokenMintY",isMut:!1,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"oracle",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"ixData",type:{defined:"InitPermissionPairIx"}}]},{name:"initializeBinArrayBitmapExtension",accounts:[{name:"lbPair",isMut:!1,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,docs:["Initialize an account to store if a bin array is initialized."]},{name:"funder",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"initializeBinArray",accounts:[{name:"lbPair",isMut:!1,isSigner:!1},{name:"binArray",isMut:!0,isSigner:!1},{name:"funder",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"index",type:"i64"}]},{name:"addLiquidity",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userTokenX",isMut:!0,isSigner:!1},{name:"userTokenY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"liquidityParameter",type:{defined:"LiquidityParameter"}}]},{name:"addLiquidityByWeight",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userTokenX",isMut:!0,isSigner:!1},{name:"userTokenY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"liquidityParameter",type:{defined:"LiquidityParameterByWeight"}}]},{name:"addLiquidityByStrategy",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userTokenX",isMut:!0,isSigner:!1},{name:"userTokenY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"liquidityParameter",type:{defined:"LiquidityParameterByStrategy"}}]},{name:"addLiquidityByStrategyOneSide",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userToken",isMut:!0,isSigner:!1},{name:"reserve",isMut:!0,isSigner:!1},{name:"tokenMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"liquidityParameter",type:{defined:"LiquidityParameterByStrategyOneSide"}}]},{name:"addLiquidityOneSide",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userToken",isMut:!0,isSigner:!1},{name:"reserve",isMut:!0,isSigner:!1},{name:"tokenMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"liquidityParameter",type:{defined:"LiquidityOneSideParameter"}}]},{name:"removeLiquidity",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userTokenX",isMut:!0,isSigner:!1},{name:"userTokenY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"binLiquidityRemoval",type:{vec:{defined:"BinLiquidityReduction"}}}]},{name:"initializePosition",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"position",isMut:!0,isSigner:!0},{name:"lbPair",isMut:!1,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"lowerBinId",type:"i32"},{name:"width",type:"i32"}]},{name:"initializePositionPda",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"base",isMut:!1,isSigner:!0},{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!1,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0,docs:["owner"]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"lowerBinId",type:"i32"},{name:"width",type:"i32"}]},{name:"initializePositionByOperator",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"base",isMut:!1,isSigner:!0},{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!1,isSigner:!1},{name:"operator",isMut:!1,isSigner:!0,docs:["operator"]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"lowerBinId",type:"i32"},{name:"width",type:"i32"},{name:"owner",type:"publicKey"},{name:"feeOwner",type:"publicKey"}]},{name:"updatePositionOperator",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"operator",type:"publicKey"}]},{name:"swap",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!1,isSigner:!1,isOptional:!0},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"userTokenIn",isMut:!0,isSigner:!1},{name:"userTokenOut",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"oracle",isMut:!0,isSigner:!1},{name:"hostFeeIn",isMut:!0,isSigner:!1,isOptional:!0},{name:"user",isMut:!1,isSigner:!0},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"amountIn",type:"u64"},{name:"minAmountOut",type:"u64"}]},{name:"withdrawProtocolFee",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"receiverTokenX",isMut:!0,isSigner:!1},{name:"receiverTokenY",isMut:!0,isSigner:!1},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1}],args:[{name:"amountX",type:"u64"},{name:"amountY",type:"u64"}]},{name:"updateFeeOwner",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"newFeeOwner",isMut:!1,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0}],args:[]},{name:"initializeReward",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"rewardVault",isMut:!0,isSigner:!1},{name:"rewardMint",isMut:!1,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"rewardIndex",type:"u64"},{name:"rewardDuration",type:"u64"},{name:"funder",type:"publicKey"}]},{name:"fundReward",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"rewardVault",isMut:!0,isSigner:!1},{name:"rewardMint",isMut:!1,isSigner:!1},{name:"funderTokenAccount",isMut:!0,isSigner:!1},{name:"funder",isMut:!1,isSigner:!0},{name:"binArray",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"rewardIndex",type:"u64"},{name:"amount",type:"u64"},{name:"carryForward",type:"bool"}]},{name:"updateRewardFunder",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"rewardIndex",type:"u64"},{name:"newFunder",type:"publicKey"}]},{name:"updateRewardDuration",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0},{name:"binArray",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"rewardIndex",type:"u64"},{name:"newDuration",type:"u64"}]},{name:"claimReward",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"position",isMut:!0,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"rewardVault",isMut:!0,isSigner:!1},{name:"rewardMint",isMut:!1,isSigner:!1},{name:"userTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"rewardIndex",type:"u64"}]},{name:"claimFee",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"position",isMut:!0,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"userTokenX",isMut:!0,isSigner:!1},{name:"userTokenY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[]},{name:"closePosition",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"rentReceiver",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[]},{name:"updateFeeParameters",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"feeParameter",type:{defined:"FeeParameter"}}]},{name:"increaseOracleLength",accounts:[{name:"oracle",isMut:!0,isSigner:!1},{name:"funder",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"lengthToAdd",type:"u64"}]},{name:"initializePresetParameter",accounts:[{name:"presetParameter",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"ix",type:{defined:"InitPresetParametersIx"}}]},{name:"closePresetParameter",accounts:[{name:"presetParameter",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"rentReceiver",isMut:!0,isSigner:!1}],args:[]},{name:"removeAllLiquidity",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userTokenX",isMut:!0,isSigner:!1},{name:"userTokenY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[]},{name:"togglePairStatus",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0}],args:[]},{name:"updateWhitelistedWallet",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"creator",isMut:!1,isSigner:!0}],args:[{name:"wallet",type:"publicKey"}]},{name:"migratePosition",accounts:[{name:"positionV2",isMut:!0,isSigner:!0},{name:"positionV1",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rentReceiver",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[]},{name:"migrateBinArray",accounts:[{name:"lbPair",isMut:!1,isSigner:!1}],args:[]},{name:"updateFeesAndRewards",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0}],args:[]},{name:"withdrawIneligibleReward",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"rewardVault",isMut:!0,isSigner:!1},{name:"rewardMint",isMut:!1,isSigner:!1},{name:"funderTokenAccount",isMut:!0,isSigner:!1},{name:"funder",isMut:!1,isSigner:!0},{name:"binArray",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"rewardIndex",type:"u64"}]},{name:"setActivationSlot",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0}],args:[{name:"activationSlot",type:"u64"}]},{name:"setLockReleaseSlot",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!1,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"newLockReleaseSlot",type:"u64"}]},{name:"removeLiquidityByRange",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userTokenX",isMut:!0,isSigner:!1},{name:"userTokenY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"tokenXMint",isMut:!1,isSigner:!1},{name:"tokenYMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenXProgram",isMut:!1,isSigner:!1},{name:"tokenYProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"fromBinId",type:"i32"},{name:"toBinId",type:"i32"},{name:"bpsToRemove",type:"u16"}]},{name:"addLiquidityOneSidePrecise",accounts:[{name:"position",isMut:!0,isSigner:!1},{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!0,isSigner:!1,isOptional:!0},{name:"userToken",isMut:!0,isSigner:!1},{name:"reserve",isMut:!0,isSigner:!1},{name:"tokenMint",isMut:!1,isSigner:!1},{name:"binArrayLower",isMut:!0,isSigner:!1},{name:"binArrayUpper",isMut:!0,isSigner:!1},{name:"sender",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"parameter",type:{defined:"AddLiquiditySingleSidePreciseParameter"}}]},{name:"goToABin",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"binArrayBitmapExtension",isMut:!1,isSigner:!1,isOptional:!0},{name:"fromBinArray",isMut:!1,isSigner:!1,isOptional:!0},{name:"toBinArray",isMut:!1,isSigner:!1,isOptional:!0},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"binId",type:"i32"}]},{name:"setPreActivationSlotDuration",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"creator",isMut:!1,isSigner:!0}],args:[{name:"preActivationSlotDuration",type:"u16"}]},{name:"setPreActivationSwapAddress",accounts:[{name:"lbPair",isMut:!0,isSigner:!1},{name:"creator",isMut:!1,isSigner:!0}],args:[{name:"preActivationSwapAddress",type:"publicKey"}]}],accounts:[{name:"binArrayBitmapExtension",type:{kind:"struct",fields:[{name:"lbPair",type:"publicKey"},{name:"positiveBinArrayBitmap",docs:["Packed initialized bin array state for start_bin_index is positive"],type:{array:[{array:["u64",8]},12]}},{name:"negativeBinArrayBitmap",docs:["Packed initialized bin array state for start_bin_index is negative"],type:{array:[{array:["u64",8]},12]}}]}},{name:"binArray",docs:["An account to contain a range of bin. For example: Bin 100 <-> 200.","For example:","BinArray index: 0 contains bin 0 <-> 599","index: 2 contains bin 600 <-> 1199, ..."],type:{kind:"struct",fields:[{name:"index",type:"i64"},{name:"version",docs:["Version of binArray"],type:"u8"},{name:"padding",type:{array:["u8",7]}},{name:"lbPair",type:"publicKey"},{name:"bins",type:{array:[{defined:"Bin"},70]}}]}},{name:"lbPair",type:{kind:"struct",fields:[{name:"parameters",type:{defined:"StaticParameters"}},{name:"vParameters",type:{defined:"VariableParameters"}},{name:"bumpSeed",type:{array:["u8",1]}},{name:"binStepSeed",docs:["Bin step signer seed"],type:{array:["u8",2]}},{name:"pairType",docs:["Type of the pair"],type:"u8"},{name:"activeId",docs:["Active bin id"],type:"i32"},{name:"binStep",docs:["Bin step. Represent the price increment / decrement."],type:"u16"},{name:"status",docs:["Status of the pair. Check PairStatus enum."],type:"u8"},{name:"requireBaseFactorSeed",type:"u8"},{name:"baseFactorSeed",type:{array:["u8",2]}},{name:"padding1",type:{array:["u8",2]}},{name:"tokenXMint",docs:["Token X mint"],type:"publicKey"},{name:"tokenYMint",docs:["Token Y mint"],type:"publicKey"},{name:"reserveX",docs:["LB token X vault"],type:"publicKey"},{name:"reserveY",docs:["LB token Y vault"],type:"publicKey"},{name:"protocolFee",docs:["Uncollected protocol fee"],type:{defined:"ProtocolFee"}},{name:"feeOwner",docs:["Protocol fee owner,"],type:"publicKey"},{name:"rewardInfos",docs:["Farming reward information"],type:{array:[{defined:"RewardInfo"},2]}},{name:"oracle",docs:["Oracle pubkey"],type:"publicKey"},{name:"binArrayBitmap",docs:["Packed initialized bin array state"],type:{array:["u64",16]}},{name:"lastUpdatedAt",docs:["Last time the pool fee parameter was updated"],type:"i64"},{name:"whitelistedWallet",docs:["Whitelisted wallet"],type:"publicKey"},{name:"preActivationSwapAddress",docs:["Address allowed to swap when the current slot is greater than or equal to the pre-activation slot. The pre-activation slot is calculated as `activation_slot - pre_activation_slot_duration`."],type:"publicKey"},{name:"baseKey",docs:["Base keypair. Only required for permission pair"],type:"publicKey"},{name:"activationSlot",docs:["Slot to enable the pair. Only applicable for permission pair."],type:"u64"},{name:"preActivationSlotDuration",docs:["Number of slot before activation slot. Used to calculate pre-activation slot for pre_activation_swap_address"],type:"u64"},{name:"padding2",docs:["_padding2 is reclaimed free space from swap_cap_deactivate_slot and swap_cap_amount before, BE CAREFUL FOR TOMBSTONE WHEN REUSE !!"],type:{array:["u8",8]}},{name:"lockDurationsInSlot",docs:["Liquidity lock duration for positions which created before activate. Only applicable for permission pair."],type:"u64"},{name:"creator",docs:["Pool creator"],type:"publicKey"},{name:"reserved",docs:["Reserved space for future use"],type:{array:["u8",24]}}]}},{name:"oracle",type:{kind:"struct",fields:[{name:"idx",docs:["Index of latest observation slot"],type:"u64"},{name:"activeSize",docs:["Size of active sample. Active sample is initialized observation."],type:"u64"},{name:"length",docs:["Number of observations"],type:"u64"}]}},{name:"position",type:{kind:"struct",fields:[{name:"lbPair",docs:["The LB pair of this position"],type:"publicKey"},{name:"owner",docs:["Owner of the position. Client rely on this to to fetch their positions."],type:"publicKey"},{name:"liquidityShares",docs:["Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."],type:{array:["u64",70]}},{name:"rewardInfos",docs:["Farming reward information"],type:{array:[{defined:"UserRewardInfo"},70]}},{name:"feeInfos",docs:["Swap fee to claim information"],type:{array:[{defined:"FeeInfo"},70]}},{name:"lowerBinId",docs:["Lower bin ID"],type:"i32"},{name:"upperBinId",docs:["Upper bin ID"],type:"i32"},{name:"lastUpdatedAt",docs:["Last updated timestamp"],type:"i64"},{name:"totalClaimedFeeXAmount",docs:["Total claimed token fee X"],type:"u64"},{name:"totalClaimedFeeYAmount",docs:["Total claimed token fee Y"],type:"u64"},{name:"totalClaimedRewards",docs:["Total claimed rewards"],type:{array:["u64",2]}},{name:"reserved",docs:["Reserved space for future use"],type:{array:["u8",160]}}]}},{name:"positionV2",type:{kind:"struct",fields:[{name:"lbPair",docs:["The LB pair of this position"],type:"publicKey"},{name:"owner",docs:["Owner of the position. Client rely on this to to fetch their positions."],type:"publicKey"},{name:"liquidityShares",docs:["Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."],type:{array:["u128",70]}},{name:"rewardInfos",docs:["Farming reward information"],type:{array:[{defined:"UserRewardInfo"},70]}},{name:"feeInfos",docs:["Swap fee to claim information"],type:{array:[{defined:"FeeInfo"},70]}},{name:"lowerBinId",docs:["Lower bin ID"],type:"i32"},{name:"upperBinId",docs:["Upper bin ID"],type:"i32"},{name:"lastUpdatedAt",docs:["Last updated timestamp"],type:"i64"},{name:"totalClaimedFeeXAmount",docs:["Total claimed token fee X"],type:"u64"},{name:"totalClaimedFeeYAmount",docs:["Total claimed token fee Y"],type:"u64"},{name:"totalClaimedRewards",docs:["Total claimed rewards"],type:{array:["u64",2]}},{name:"operator",docs:["Operator of position"],type:"publicKey"},{name:"lockReleaseSlot",docs:["Slot which the locked liquidity can be withdraw"],type:"u64"},{name:"subjectedToBootstrapLiquidityLocking",docs:["Is the position subjected to liquidity locking for the launch pool."],type:"u8"},{name:"feeOwner",docs:["Address is able to claim fee in this position, only valid for bootstrap_liquidity_position"],type:"publicKey"},{name:"reserved",docs:["Reserved space for future use"],type:{array:["u8",87]}}]}},{name:"presetParameter",type:{kind:"struct",fields:[{name:"binStep",docs:["Bin step. Represent the price increment / decrement."],type:"u16"},{name:"baseFactor",docs:["Used for base fee calculation. base_fee_rate = base_factor * bin_step"],type:"u16"},{name:"filterPeriod",docs:["Filter period determine high frequency trading time window."],type:"u16"},{name:"decayPeriod",docs:["Decay period determine when the volatile fee start decay / decrease."],type:"u16"},{name:"reductionFactor",docs:["Reduction factor controls the volatile fee rate decrement rate."],type:"u16"},{name:"variableFeeControl",docs:["Used to scale the variable fee component depending on the dynamic of the market"],type:"u32"},{name:"maxVolatilityAccumulator",docs:["Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."],type:"u32"},{name:"minBinId",docs:["Min bin id supported by the pool based on the configured bin step."],type:"i32"},{name:"maxBinId",docs:["Max bin id supported by the pool based on the configured bin step."],type:"i32"},{name:"protocolShare",docs:["Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"],type:"u16"}]}}],types:[{name:"LiquidityParameterByStrategyOneSide",type:{kind:"struct",fields:[{name:"amount",docs:["Amount of X token or Y token to deposit"],type:"u64"},{name:"activeId",docs:["Active bin that integrator observe off-chain"],type:"i32"},{name:"maxActiveBinSlippage",docs:["max active bin slippage allowed"],type:"i32"},{name:"strategyParameters",docs:["strategy parameters"],type:{defined:"StrategyParameters"}}]}},{name:"LiquidityParameterByStrategy",type:{kind:"struct",fields:[{name:"amountX",docs:["Amount of X token to deposit"],type:"u64"},{name:"amountY",docs:["Amount of Y token to deposit"],type:"u64"},{name:"activeId",docs:["Active bin that integrator observe off-chain"],type:"i32"},{name:"maxActiveBinSlippage",docs:["max active bin slippage allowed"],type:"i32"},{name:"strategyParameters",docs:["strategy parameters"],type:{defined:"StrategyParameters"}}]}},{name:"StrategyParameters",type:{kind:"struct",fields:[{name:"minBinId",docs:["min bin id"],type:"i32"},{name:"maxBinId",docs:["max bin id"],type:"i32"},{name:"strategyType",docs:["strategy type"],type:{defined:"StrategyType"}},{name:"parameteres",docs:["parameters"],type:{array:["u8",64]}}]}},{name:"LiquidityOneSideParameter",type:{kind:"struct",fields:[{name:"amount",docs:["Amount of X token or Y token to deposit"],type:"u64"},{name:"activeId",docs:["Active bin that integrator observe off-chain"],type:"i32"},{name:"maxActiveBinSlippage",docs:["max active bin slippage allowed"],type:"i32"},{name:"binLiquidityDist",docs:["Liquidity distribution to each bins"],type:{vec:{defined:"BinLiquidityDistributionByWeight"}}}]}},{name:"BinLiquidityDistributionByWeight",type:{kind:"struct",fields:[{name:"binId",docs:["Define the bin ID wish to deposit to."],type:"i32"},{name:"weight",docs:["weight of liquidity distributed for this bin id"],type:"u16"}]}},{name:"LiquidityParameterByWeight",type:{kind:"struct",fields:[{name:"amountX",docs:["Amount of X token to deposit"],type:"u64"},{name:"amountY",docs:["Amount of Y token to deposit"],type:"u64"},{name:"activeId",docs:["Active bin that integrator observe off-chain"],type:"i32"},{name:"maxActiveBinSlippage",docs:["max active bin slippage allowed"],type:"i32"},{name:"binLiquidityDist",docs:["Liquidity distribution to each bins"],type:{vec:{defined:"BinLiquidityDistributionByWeight"}}}]}},{name:"AddLiquiditySingleSidePreciseParameter",type:{kind:"struct",fields:[{name:"bins",type:{vec:{defined:"CompressedBinDepositAmount"}}},{name:"decompressMultiplier",type:"u64"}]}},{name:"CompressedBinDepositAmount",type:{kind:"struct",fields:[{name:"binId",type:"i32"},{name:"amount",type:"u32"}]}},{name:"BinLiquidityDistribution",type:{kind:"struct",fields:[{name:"binId",docs:["Define the bin ID wish to deposit to."],type:"i32"},{name:"distributionX",docs:["DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."],type:"u16"},{name:"distributionY",docs:["DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."],type:"u16"}]}},{name:"LiquidityParameter",type:{kind:"struct",fields:[{name:"amountX",docs:["Amount of X token to deposit"],type:"u64"},{name:"amountY",docs:["Amount of Y token to deposit"],type:"u64"},{name:"binLiquidityDist",docs:["Liquidity distribution to each bins"],type:{vec:{defined:"BinLiquidityDistribution"}}}]}},{name:"InitPermissionPairIx",type:{kind:"struct",fields:[{name:"activeId",type:"i32"},{name:"binStep",type:"u16"},{name:"baseFactor",type:"u16"},{name:"minBinId",type:"i32"},{name:"maxBinId",type:"i32"},{name:"lockDurationInSlot",type:"u64"}]}},{name:"InitPresetParametersIx",type:{kind:"struct",fields:[{name:"binStep",docs:["Bin step. Represent the price increment / decrement."],type:"u16"},{name:"baseFactor",docs:["Used for base fee calculation. base_fee_rate = base_factor * bin_step"],type:"u16"},{name:"filterPeriod",docs:["Filter period determine high frequency trading time window."],type:"u16"},{name:"decayPeriod",docs:["Decay period determine when the volatile fee start decay / decrease."],type:"u16"},{name:"reductionFactor",docs:["Reduction factor controls the volatile fee rate decrement rate."],type:"u16"},{name:"variableFeeControl",docs:["Used to scale the variable fee component depending on the dynamic of the market"],type:"u32"},{name:"maxVolatilityAccumulator",docs:["Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."],type:"u32"},{name:"minBinId",docs:["Min bin id supported by the pool based on the configured bin step."],type:"i32"},{name:"maxBinId",docs:["Max bin id supported by the pool based on the configured bin step."],type:"i32"},{name:"protocolShare",docs:["Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"],type:"u16"}]}},{name:"BinLiquidityReduction",type:{kind:"struct",fields:[{name:"binId",type:"i32"},{name:"bpsToRemove",type:"u16"}]}},{name:"FeeParameter",type:{kind:"struct",fields:[{name:"protocolShare",docs:["Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"],type:"u16"},{name:"baseFactor",docs:["Base factor for base fee rate"],type:"u16"}]}},{name:"Bin",type:{kind:"struct",fields:[{name:"amountX",docs:["Amount of token X in the bin. This already excluded protocol fees."],type:"u64"},{name:"amountY",docs:["Amount of token Y in the bin. This already excluded protocol fees."],type:"u64"},{name:"price",docs:["Bin price"],type:"u128"},{name:"liquiditySupply",docs:["Liquidities of the bin. This is the same as LP mint supply. q-number"],type:"u128"},{name:"rewardPerTokenStored",docs:["reward_a_per_token_stored"],type:{array:["u128",2]}},{name:"feeAmountXPerTokenStored",docs:["Swap fee amount of token X per liquidity deposited."],type:"u128"},{name:"feeAmountYPerTokenStored",docs:["Swap fee amount of token Y per liquidity deposited."],type:"u128"},{name:"amountXIn",docs:["Total token X swap into the bin. Only used for tracking purpose."],type:"u128"},{name:"amountYIn",docs:["Total token Y swap into he bin. Only used for tracking purpose."],type:"u128"}]}},{name:"ProtocolFee",type:{kind:"struct",fields:[{name:"amountX",type:"u64"},{name:"amountY",type:"u64"}]}},{name:"RewardInfo",docs:["Stores the state relevant for tracking liquidity mining rewards"],type:{kind:"struct",fields:[{name:"mint",docs:["Reward token mint."],type:"publicKey"},{name:"vault",docs:["Reward vault token account."],type:"publicKey"},{name:"funder",docs:["Authority account that allows to fund rewards"],type:"publicKey"},{name:"rewardDuration",docs:["TODO check whether we need to store it in pool"],type:"u64"},{name:"rewardDurationEnd",docs:["TODO check whether we need to store it in pool"],type:"u64"},{name:"rewardRate",docs:["TODO check whether we need to store it in pool"],type:"u128"},{name:"lastUpdateTime",docs:["The last time reward states were updated."],type:"u64"},{name:"cumulativeSecondsWithEmptyLiquidityReward",docs:["Accumulated seconds where when farm distribute rewards, but the bin is empty. The reward will be accumulated for next reward time window."],type:"u64"}]}},{name:"Observation",type:{kind:"struct",fields:[{name:"cumulativeActiveBinId",docs:["Cumulative active bin ID"],type:"i128"},{name:"createdAt",docs:["Observation sample created timestamp"],type:"i64"},{name:"lastUpdatedAt",docs:["Observation sample last updated timestamp"],type:"i64"}]}},{name:"StaticParameters",docs:["Parameter that set by the protocol"],type:{kind:"struct",fields:[{name:"baseFactor",docs:["Used for base fee calculation. base_fee_rate = base_factor * bin_step"],type:"u16"},{name:"filterPeriod",docs:["Filter period determine high frequency trading time window."],type:"u16"},{name:"decayPeriod",docs:["Decay period determine when the volatile fee start decay / decrease."],type:"u16"},{name:"reductionFactor",docs:["Reduction factor controls the volatile fee rate decrement rate."],type:"u16"},{name:"variableFeeControl",docs:["Used to scale the variable fee component depending on the dynamic of the market"],type:"u32"},{name:"maxVolatilityAccumulator",docs:["Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."],type:"u32"},{name:"minBinId",docs:["Min bin id supported by the pool based on the configured bin step."],type:"i32"},{name:"maxBinId",docs:["Max bin id supported by the pool based on the configured bin step."],type:"i32"},{name:"protocolShare",docs:["Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"],type:"u16"},{name:"padding",docs:["Padding for bytemuck safe alignment"],type:{array:["u8",6]}}]}},{name:"VariableParameters",docs:["Parameters that changes based on dynamic of the market"],type:{kind:"struct",fields:[{name:"volatilityAccumulator",docs:["Volatility accumulator measure the number of bin crossed since reference bin ID. Normally (without filter period taken into consideration), reference bin ID is the active bin of last swap.","It affects the variable fee rate"],type:"u32"},{name:"volatilityReference",docs:["Volatility reference is decayed volatility accumulator. It is always <= volatility_accumulator"],type:"u32"},{name:"indexReference",docs:["Active bin id of last swap."],type:"i32"},{name:"padding",docs:["Padding for bytemuck safe alignment"],type:{array:["u8",4]}},{name:"lastUpdateTimestamp",docs:["Last timestamp the variable parameters was updated"],type:"i64"},{name:"padding1",docs:["Padding for bytemuck safe alignment"],type:{array:["u8",8]}}]}},{name:"FeeInfo",type:{kind:"struct",fields:[{name:"feeXPerTokenComplete",type:"u128"},{name:"feeYPerTokenComplete",type:"u128"},{name:"feeXPending",type:"u64"},{name:"feeYPending",type:"u64"}]}},{name:"UserRewardInfo",type:{kind:"struct",fields:[{name:"rewardPerTokenCompletes",type:{array:["u128",2]}},{name:"rewardPendings",type:{array:["u64",2]}}]}},{name:"StrategyType",type:{kind:"enum",variants:[{name:"SpotOneSide"},{name:"CurveOneSide"},{name:"BidAskOneSide"},{name:"SpotBalanced"},{name:"CurveBalanced"},{name:"BidAskBalanced"},{name:"SpotImBalanced"},{name:"CurveImBalanced"},{name:"BidAskImBalanced"}]}},{name:"Rounding",type:{kind:"enum",variants:[{name:"Up"},{name:"Down"}]}},{name:"LayoutVersion",docs:["Layout version"],type:{kind:"enum",variants:[{name:"V0"},{name:"V1"}]}},{name:"PairType",docs:["Type of the Pair. 0 = Permissionless, 1 = Permission. Putting 0 as permissionless for backward compatibility."],type:{kind:"enum",variants:[{name:"Permissionless"},{name:"Permission"}]}},{name:"PairStatus",docs:["Pair status. 0 = Enabled, 1 = Disabled. Putting 0 as enabled for backward compatibility."],type:{kind:"enum",variants:[{name:"Enabled"},{name:"Disabled"}]}}],events:[{name:"CompositionFee",fields:[{name:"from",type:"publicKey",index:!1},{name:"binId",type:"i16",index:!1},{name:"tokenXFeeAmount",type:"u64",index:!1},{name:"tokenYFeeAmount",type:"u64",index:!1},{name:"protocolTokenXFeeAmount",type:"u64",index:!1},{name:"protocolTokenYFeeAmount",type:"u64",index:!1}]},{name:"AddLiquidity",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"from",type:"publicKey",index:!1},{name:"position",type:"publicKey",index:!1},{name:"amounts",type:{array:["u64",2]},index:!1},{name:"activeBinId",type:"i32",index:!1}]},{name:"RemoveLiquidity",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"from",type:"publicKey",index:!1},{name:"position",type:"publicKey",index:!1},{name:"amounts",type:{array:["u64",2]},index:!1},{name:"activeBinId",type:"i32",index:!1}]},{name:"Swap",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"from",type:"publicKey",index:!1},{name:"startBinId",type:"i32",index:!1},{name:"endBinId",type:"i32",index:!1},{name:"amountIn",type:"u64",index:!1},{name:"amountOut",type:"u64",index:!1},{name:"swapForY",type:"bool",index:!1},{name:"fee",type:"u64",index:!1},{name:"protocolFee",type:"u64",index:!1},{name:"feeBps",type:"u128",index:!1},{name:"hostFee",type:"u64",index:!1}]},{name:"ClaimReward",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"position",type:"publicKey",index:!1},{name:"owner",type:"publicKey",index:!1},{name:"rewardIndex",type:"u64",index:!1},{name:"totalReward",type:"u64",index:!1}]},{name:"FundReward",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"funder",type:"publicKey",index:!1},{name:"rewardIndex",type:"u64",index:!1},{name:"amount",type:"u64",index:!1}]},{name:"InitializeReward",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"rewardMint",type:"publicKey",index:!1},{name:"funder",type:"publicKey",index:!1},{name:"rewardIndex",type:"u64",index:!1},{name:"rewardDuration",type:"u64",index:!1}]},{name:"UpdateRewardDuration",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"rewardIndex",type:"u64",index:!1},{name:"oldRewardDuration",type:"u64",index:!1},{name:"newRewardDuration",type:"u64",index:!1}]},{name:"UpdateRewardFunder",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"rewardIndex",type:"u64",index:!1},{name:"oldFunder",type:"publicKey",index:!1},{name:"newFunder",type:"publicKey",index:!1}]},{name:"PositionClose",fields:[{name:"position",type:"publicKey",index:!1},{name:"owner",type:"publicKey",index:!1}]},{name:"ClaimFee",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"position",type:"publicKey",index:!1},{name:"owner",type:"publicKey",index:!1},{name:"feeX",type:"u64",index:!1},{name:"feeY",type:"u64",index:!1}]},{name:"LbPairCreate",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"binStep",type:"u16",index:!1},{name:"tokenX",type:"publicKey",index:!1},{name:"tokenY",type:"publicKey",index:!1}]},{name:"PositionCreate",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"position",type:"publicKey",index:!1},{name:"owner",type:"publicKey",index:!1}]},{name:"FeeParameterUpdate",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"protocolShare",type:"u16",index:!1},{name:"baseFactor",type:"u16",index:!1}]},{name:"IncreaseObservation",fields:[{name:"oracle",type:"publicKey",index:!1},{name:"newObservationLength",type:"u64",index:!1}]},{name:"WithdrawIneligibleReward",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"rewardMint",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]},{name:"UpdatePositionOperator",fields:[{name:"position",type:"publicKey",index:!1},{name:"oldOperator",type:"publicKey",index:!1},{name:"newOperator",type:"publicKey",index:!1}]},{name:"UpdatePositionLockReleaseSlot",fields:[{name:"position",type:"publicKey",index:!1},{name:"currentSlot",type:"u64",index:!1},{name:"newLockReleaseSlot",type:"u64",index:!1},{name:"oldLockReleaseSlot",type:"u64",index:!1},{name:"sender",type:"publicKey",index:!1}]},{name:"GoToABin",fields:[{name:"lbPair",type:"publicKey",index:!1},{name:"fromBinId",type:"i32",index:!1},{name:"toBinId",type:"i32",index:!1}]}],errors:[{code:6e3,name:"InvalidStartBinIndex",msg:"Invalid start bin index"},{code:6001,name:"InvalidBinId",msg:"Invalid bin id"},{code:6002,name:"InvalidInput",msg:"Invalid input data"},{code:6003,name:"ExceededAmountSlippageTolerance",msg:"Exceeded amount slippage tolerance"},{code:6004,name:"ExceededBinSlippageTolerance",msg:"Exceeded bin slippage tolerance"},{code:6005,name:"CompositionFactorFlawed",msg:"Composition factor flawed"},{code:6006,name:"NonPresetBinStep",msg:"Non preset bin step"},{code:6007,name:"ZeroLiquidity",msg:"Zero liquidity"},{code:6008,name:"InvalidPosition",msg:"Invalid position"},{code:6009,name:"BinArrayNotFound",msg:"Bin array not found"},{code:6010,name:"InvalidTokenMint",msg:"Invalid token mint"},{code:6011,name:"InvalidAccountForSingleDeposit",msg:"Invalid account for single deposit"},{code:6012,name:"PairInsufficientLiquidity",msg:"Pair insufficient liquidity"},{code:6013,name:"InvalidFeeOwner",msg:"Invalid fee owner"},{code:6014,name:"InvalidFeeWithdrawAmount",msg:"Invalid fee withdraw amount"},{code:6015,name:"InvalidAdmin",msg:"Invalid admin"},{code:6016,name:"IdenticalFeeOwner",msg:"Identical fee owner"},{code:6017,name:"InvalidBps",msg:"Invalid basis point"},{code:6018,name:"MathOverflow",msg:"Math operation overflow"},{code:6019,name:"TypeCastFailed",msg:"Type cast error"},{code:6020,name:"InvalidRewardIndex",msg:"Invalid reward index"},{code:6021,name:"InvalidRewardDuration",msg:"Invalid reward duration"},{code:6022,name:"RewardInitialized",msg:"Reward already initialized"},{code:6023,name:"RewardUninitialized",msg:"Reward not initialized"},{code:6024,name:"IdenticalFunder",msg:"Identical funder"},{code:6025,name:"RewardCampaignInProgress",msg:"Reward campaign in progress"},{code:6026,name:"IdenticalRewardDuration",msg:"Reward duration is the same"},{code:6027,name:"InvalidBinArray",msg:"Invalid bin array"},{code:6028,name:"NonContinuousBinArrays",msg:"Bin arrays must be continuous"},{code:6029,name:"InvalidRewardVault",msg:"Invalid reward vault"},{code:6030,name:"NonEmptyPosition",msg:"Position is not empty"},{code:6031,name:"UnauthorizedAccess",msg:"Unauthorized access"},{code:6032,name:"InvalidFeeParameter",msg:"Invalid fee parameter"},{code:6033,name:"MissingOracle",msg:"Missing oracle account"},{code:6034,name:"InsufficientSample",msg:"Insufficient observation sample"},{code:6035,name:"InvalidLookupTimestamp",msg:"Invalid lookup timestamp"},{code:6036,name:"BitmapExtensionAccountIsNotProvided",msg:"Bitmap extension account is not provided"},{code:6037,name:"CannotFindNonZeroLiquidityBinArrayId",msg:"Cannot find non-zero liquidity binArrayId"},{code:6038,name:"BinIdOutOfBound",msg:"Bin id out of bound"},{code:6039,name:"InsufficientOutAmount",msg:"Insufficient amount in for minimum out"},{code:6040,name:"InvalidPositionWidth",msg:"Invalid position width"},{code:6041,name:"ExcessiveFeeUpdate",msg:"Excessive fee update"},{code:6042,name:"PoolDisabled",msg:"Pool disabled"},{code:6043,name:"InvalidPoolType",msg:"Invalid pool type"},{code:6044,name:"ExceedMaxWhitelist",msg:"Whitelist for wallet is full"},{code:6045,name:"InvalidIndex",msg:"Invalid index"},{code:6046,name:"RewardNotEnded",msg:"Reward not ended"},{code:6047,name:"MustWithdrawnIneligibleReward",msg:"Must withdraw ineligible reward"},{code:6048,name:"UnauthorizedAddress",msg:"Unauthorized address"},{code:6049,name:"OperatorsAreTheSame",msg:"Cannot update because operators are the same"},{code:6050,name:"WithdrawToWrongTokenAccount",msg:"Withdraw to wrong token account"},{code:6051,name:"WrongRentReceiver",msg:"Wrong rent receiver"},{code:6052,name:"AlreadyPassActivationSlot",msg:"Already activated"},{code:6053,name:"LastSlotCannotBeSmallerThanActivateSlot",msg:"Last slot cannot be smaller than activate slot"},{code:6054,name:"ExceedMaxSwappedAmount",msg:"Swapped amount is exceeded max swapped amount"},{code:6055,name:"InvalidStrategyParameters",msg:"Invalid strategy parameters"},{code:6056,name:"LiquidityLocked",msg:"Liquidity locked"},{code:6057,name:"InvalidLockReleaseSlot",msg:"Invalid lock release slot"},{code:6058,name:"BinRangeIsNotEmpty",msg:"Bin range is not empty"}]},P={devnet:"LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo",localhost:"LbVRzDTvBDEcrthxfZ4RL6yiq3uZw8bS6MwtdY6UhFQ","mainnet-beta":"LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo"},S=((n=S||{}).MAINNET="mainnet-beta",n.TESTNET="testnet",n.DEVNET="devnet",n.LOCAL="localhost",n);new m.BN(1).shln(64);var M=new m.BN(1e9),v=new m.BN(1e8),k=Object.entries(B.constants),I=new m.BN(k.find(([e,t])=>"MAX_BIN_PER_ARRAY"==t.name)?.[1].value??0),A=new m.BN(k.find(([e,t])=>"MAX_BIN_PER_POSITION"==t.name)?.[1].value??0),N=new m.BN(k.find(([e,t])=>"BIN_ARRAY_BITMAP_SIZE"==t.name)?.[1].value??0),x=new m.BN(k.find(([e,t])=>"EXTENSION_BINARRAY_BITMAP_SIZE"==t.name)?.[1].value??0);new u.PublicKey("HrY9qR5TiB2xPzzvbBu5KrBorMfYGQXh9osXydz4jy9s");var Y=((a=Y||{})[a.V1=0]="V1",a[a.V2=1]="V2",a),X=((r=X||{})[r.Permissionless=0]="Permissionless",r[r.Permissioned=1]="Permissioned",r),T=((o=T||{})[o.SpotOneSide=0]="SpotOneSide",o[o.CurveOneSide=1]="CurveOneSide",o[o.BidAskOneSide=2]="BidAskOneSide",o[o.SpotImBalanced=3]="SpotImBalanced",o[o.CurveImBalanced=4]="CurveImBalanced",o[o.BidAskImBalanced=5]="BidAskImBalanced",o[o.SpotBalanced=6]="SpotBalanced",o[o.CurveBalanced=7]="CurveBalanced",o[o.BidAskBalanced=8]="BidAskBalanced",o),K=((s=K||{})[s.U1024=0]="U1024",s[s.U512=1]="U512",s),L=new b(524288),E=new b(1).shln(64),O=new b(2).pow(new b(128)).sub(new b(1));function _(e,t){let i=new h.Z(t).div(new h.Z(1e4));return new h.Z(1).add(new h.Z(i)).pow(new h.Z(e))}function q(e,t,i,n){let a=new m.BN(0),r=i.map(i=>{let r=new m.BN(_(i.binId,n).mul(1e12).floor().toString()),o=e.mul(new m.BN(i.xAmountBpsOfTotal)).mul(new m.BN(r)).div(new m.BN(1e4)).div(new m.BN(1e12)).add(t.mul(new m.BN(i.yAmountBpsOfTotal)).div(new m.BN(1e4)));return a=a.add(o),{binId:i.binId,quoteAmount:o}});return a.eq(new m.BN(0))?[]:r.map(e=>{let t=Math.floor(e.quoteAmount.mul(new m.BN(65535)).div(a).toNumber());return{binId:e.binId,weight:t}}).filter(e=>e.weight>0)}function Z(e,t,i,n){return F(e,t,new m.BN(1).shln(i),n)}function R(e,t,i,n){return F(e,new m.BN(1).shln(i),t,n)}function F(e,t,i,n){let{div:a,mod:r}=e.mul(t).divmod(i);return 0!=n||r.isZero()?a:a.add(new m.BN(1))}function D(e,t){let i=t.shln(64).div(new m.BN(1e4));return function(e,t){let i=t.isNeg();if(t.isZero())return E;if((t=i?t.abs():t).gt(L))return new b(0);let n=e,a=E;return(n.gte(a)&&(n=O.div(n),i=!i),t.and(new b(1)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(2)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(4)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(8)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(16)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(32)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(64)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(128)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(256)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(512)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(1024)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(2048)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(4096)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(8192)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(16384)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(32768)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(65536)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(131072)).isZero()||(a=a.mul(n).shrn(64)),n=n.mul(n).shrn(64),t.and(new b(262144)).isZero()||(a=a.mul(n).shrn(64)),a.isZero())?new b(0):(i&&(a=O.div(a)),a)}(E.add(i),e)}function U(e,t,i,n,a,r,o,s){let u=new h.Z(1+t/1e4).pow(i.toNumber()).mul(new h.Z(10**(n-a))),m=o.sub(r),d=u.sub(new h.Z(r));return new h.Z(e.toString()).mul(d.div(m).pow(s)).floor()}function C(e,t){let[i,n]=1==e.toBuffer().compare(t.toBuffer())?[t,e]:[e,t];return[i,n]}function z(e,t,i,n,a){let[r,o]=C(e,t);return u.PublicKey.findProgramAddressSync([r.toBuffer(),o.toBuffer(),new Uint8Array(i.toArrayLike(f,"le",2)),new Uint8Array(n.toArrayLike(f,"le",2))],a)}function V(e,t){return u.PublicKey.findProgramAddressSync([f.from("oracle"),e.toBytes()],t)}function W(e,t,i,n,a){let r;return r=new Uint8Array(i.isNeg()?i.toTwos(32).toArrayLike(f,"le",4):i.toArrayLike(f,"le",4)),u.PublicKey.findProgramAddressSync([f.from("position"),e.toBuffer(),t.toBuffer(),r,new Uint8Array(n.toBuffer("le",4))],a)}function H(e,t,i){let n;return n=new Uint8Array(t.isNeg()?t.toTwos(64).toArrayLike(f,"le",8):t.toArrayLike(f,"le",8)),u.PublicKey.findProgramAddressSync([f.from("bin_array"),e.toBytes(),n],i)}function $(e,t,i){return u.PublicKey.findProgramAddressSync([t.toBuffer(),e.toBuffer()],i)}function G(){return[N.neg(),N.sub(new m.BN(1))]}function j(e,t){let i=f.concat(e.map(e=>e.toArrayLike(f,"le",8)));return new m.BN(i,"le")}function J(e,t,i){let n=e=>e.gt(new m.BN(0))?e.mod(N):e.add(new m.BN(1)).neg().mod(N),a=e=>e.gt(new m.BN(0))?e.div(N).sub(new m.BN(1)):e.add(new m.BN(1)).neg().div(N).sub(new m.BN(1));if(e<=t)for(let r=e;r<=t;r++){let e=n(new m.BN(r)).toNumber(),t=a(new m.BN(r)).toNumber();if(j(r>0?i.positiveBinArrayBitmap[t]:i.negativeBinArrayBitmap[t],1).testn(e))return r}else for(let r=e;r>=t;r--){let e=n(new m.BN(r)).toNumber(),t=a(new m.BN(r)).toNumber();if(j(r>0?i.positiveBinArrayBitmap[t]:i.negativeBinArrayBitmap[t],1).testn(e))return r}return null}function Q(e){let[t,i]=G();return e.gt(i)||e.lt(t)}function ee(e,t){return u.PublicKey.findProgramAddressSync([f.from("bitmap"),e.toBytes()],t)}function et(e){let{div:t,mod:i}=e.divmod(I);return e.isNeg()&&!i.isZero()?t.sub(new m.BN(1)):t}function ei(e){let t=e.mul(I),i=t.add(I).sub(new m.BN(1));return[t,i]}function en(e,t){let[i,n]=ei(t);return e.gte(i)&&e.lte(n)}function ea(e,t){let[i,n]=ei(t.index),a=0;if(e>0)a=e-i.toNumber();else{let t=n.toNumber()-e;a=I.toNumber()-t-1}return t.bins[a]}function er(e,t,i,n){let[a,r]=G(),o=et(t);for(;;)if(Q(o)){if(null===n)return null;let[t,i]=[N.neg().mul(x.add(new m.BN(1))),N.mul(x.add(new m.BN(1))).sub(new m.BN(1))];if(o.isNeg()){if(e){let e=J(o.toNumber(),t.toNumber(),n);if(null!==e)return new m.BN(e);return null}{let e=J(o.toNumber(),N.neg().sub(new m.BN(1)).toNumber(),n);if(null!==e)return new m.BN(e);o=N.neg()}}else if(e){let e=J(o.toNumber(),N.toNumber(),n);if(null!==e)return new m.BN(e);o=N.sub(new m.BN(1))}else{let e=J(o.toNumber(),i.toNumber(),n);if(null!==e)return new m.BN(e);return null}}else{let t={bits:1024},n=o.add(N),s=j(i.binArrayBitmap,0);if(e){let e=new m.BN(t.bits-1).sub(n),i=function(e,t){let i=t-1;if(e.isZero())return null;for(let t=i;t>=0;t--)if(e.testn(t))return i-t;return null}(s.shln(e.toNumber()),t.bits);if(null!==i)return o.sub(new m.BN(i));o=a.sub(new m.BN(1))}else{let e=function(e,t){if(e.isZero())return null;for(let i=0;i<t;i++)if(e.testn(i))return i;return null}(s.shrn(n.toNumber()),t.bits);if(null!==e)return o.add(new m.BN(e));o=r.add(new m.BN(1))}}}function eo(e,t,i,n,a){let r=er(e,t,i,n);if(null==r)return null;let o=a.find(e=>e.account.index.eq(r));if(!o)throw Error("Bin array not found based on indexing");return o}function es(e,t,i){let n=new m.BN(t.baseFactor).mul(new m.BN(e)).mul(new m.BN(10)).add(function(e,t,i){if(t.variableFeeControl>0){let n=new m.BN(i.volatilityAccumulator).mul(new m.BN(e)).pow(new m.BN(2));return new m.BN(t.variableFeeControl).mul(n).add(new m.BN(99999999999)).div(new m.BN(1e11))}return new m.BN(0)}(e,t,i));return n.gt(v)?v:n}function eu(e,t,i,n){let a=es(e,t,i);return n.mul(a).add(M.sub(new m.BN(1))).div(M)}function em(e,t){return e.mul(new m.BN(t.protocolShare)).div(new m.BN(1e4))}function ed(e,t,i,n,a,r){let o,s,u,d,l,c;if(r&&e.amountY.isZero()||!r&&e.amountX.isZero())return{amountIn:new m.BN(0),amountOut:new m.BN(0),fee:new m.BN(0),protocolFee:new m.BN(0)};r?(o=e.amountY,s=R(e.amountY,e.price,64,0)):(o=e.amountX,s=Z(e.amountX,e.price,64,0));let p=function(e,t,i,n){let a=es(e,t,i),r=M.sub(a);return n.mul(a).add(r).sub(new m.BN(1)).div(r)}(t,i,n,s);if(s=s.add(p),a.gt(s))u=s,d=o,l=p,c=em(p,i);else{l=eu(t,i,n,a);let s=ep(e,a.sub(l),r);d=s.gt(o)?o:s,c=em(l,i),u=a}return{amountIn:u,amountOut:d,fee:l,protocolFee:c}}function el(e){let{maxBinId:t,minBinId:i,strategyType:n}=e;switch(n){case 0:return{minBinId:i,maxBinId:t,strategyType:{spotOneSide:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 1:return{minBinId:i,maxBinId:t,strategyType:{curveOneSide:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 2:return{minBinId:i,maxBinId:t,strategyType:{bidAskOneSide:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 6:return{minBinId:i,maxBinId:t,strategyType:{spotBalanced:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 7:return{minBinId:i,maxBinId:t,strategyType:{curveBalanced:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 8:return{minBinId:i,maxBinId:t,strategyType:{bidAskBalanced:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 3:return{minBinId:i,maxBinId:t,strategyType:{spotImBalanced:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 4:return{minBinId:i,maxBinId:t,strategyType:{curveImBalanced:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data};case 5:return{minBinId:i,maxBinId:t,strategyType:{bidAskImBalanced:{}},parameteres:f.from(Array(64).fill(0)).toJSON().data}}}function ec(e,t){return Array.apply(0,Array(Math.ceil(e.length/t))).map((i,n)=>e.slice(n*t,(n+1)*t))}function ep(e,t,i){return i?Z(t,e.price,64,1):R(t,e.price,64,1)}async function ey(e,t){let i=await (0,d.ih)(e,t);return await i.decimals}var eg=async(e,t,i,n=i,a=!0)=>{let r=(0,d.MO)(t,i,a);try{return await (0,l.D0)(e,r),{ataPubKey:r,ix:void 0}}catch(e){if(e instanceof c.We||e instanceof c.Or){let e=(0,p.Ek)(n,r,i,t);return{ataPubKey:r,ix:e}}throw console.error("Error::getOrCreateATAInstruction",e),e}},eh=(e,t,i)=>[u.SystemProgram.transfer({fromPubkey:e,toPubkey:t,lamports:i}),new u.TransactionInstruction({keys:[{pubkey:t,isSigner:!1,isWritable:!0}],data:f.from(new Uint8Array([17])),programId:y.H_})],eb=async(e,t=!0)=>{let i=(0,d.MO)(y.Gd,e,t);return i?(0,g.Zu)(i,e,e,[],y.H_):null};async function ew(e,t,i=100){return(await Promise.all(ec(t,i).map(t=>e.getMultipleAccountsInfo(t)))).flat()}var ef=()=>u.ComputeBudgetProgram.setComputeUnitLimit({units:14e5}),eB=class{constructor(e,t,i,n,a,r,o){this.pubkey=e,this.program=t,this.lbPair=i,this.binArrayBitmapExtension=n,this.tokenX=a,this.tokenY=r,this.opt=o}static async getLbPairs(e,t){let i=new m.Y7(e,{},m.Y7.defaultOptions());return new m.$r(B,t?.programId??P[t?.cluster??"mainnet-beta"],i).account.lbPair.all()}static async getPairPubkeyIfExists(e,t,i,n,a,r){let o=r?.cluster||"mainnet-beta",s=new m.Y7(e,{},m.Y7.defaultOptions()),d=new m.$r(B,r?.programId??P[o],s);try{let[e]=z(t,i,n,a,d.programId);if(await d.account.lbPair.fetchNullable(e))return e;let[r]=function(e,t,i,n){let[a,r]=C(e,t);return u.PublicKey.findProgramAddressSync([a.toBuffer(),r.toBuffer(),new Uint8Array(i.toArrayLike(f,"le",2))],n)}(t,i,n,d.programId),o=await d.account.lbPair.fetchNullable(r);if(o&&o.parameters.baseFactor===a.toNumber())return r;return null}catch(e){return null}}static async create(e,t,i){let n;let a=i?.cluster||"mainnet-beta",r=new m.Y7(e,{},m.Y7.defaultOptions()),o=new m.$r(B,i?.programId??P[a],r),s=ee(t,o.programId)[0],u=[t,s],c=await ew(e,u),p=c[0]?.data;if(!p)throw Error(`LB Pair account ${t.toBase58()} not found`);let y=o.coder.accounts.decode("lbPair",p),g=c[1]?.data,h=null;g&&(h=o.coder.accounts.decode("binArrayBitmapExtension",g));let b=await ew(o.provider.connection,[y.reserveX,y.reserveY,y.tokenXMint,y.tokenYMint]);h&&(n={account:h,publicKey:s});let w=l.p0.decode(b[0].data),f=l.p0.decode(b[1].data),S=d.qT.decode(b[2].data).decimals,M=d.qT.decode(b[3].data).decimals,v={publicKey:y.tokenXMint,reserve:y.reserveX,amount:w.amount,decimal:S},k={publicKey:y.tokenYMint,reserve:y.reserveY,amount:f.amount,decimal:M};return new eB(t,o,y,n,v,k,i)}static async createMultiple(e,t,i){let n=i?.cluster||"mainnet-beta",a=new m.Y7(e,{},m.Y7.defaultOptions()),r=new m.$r(B,i?.programId??P[n],a),o=t.map(e=>ee(e,r.programId)[0]),s=[...t,...o],u=await ew(e,s),c=new Map;for(let e=0;e<t.length;e++){let i=t[e],n=u[e]?.data;if(!n)throw Error(`LB Pair account ${i.toBase58()} not found`);let a=r.coder.accounts.decode("lbPair",n);c.set(i.toBase58(),a)}let p=new Map;for(let e=t.length;e<u.length;e++){let i=e-t.length,n=t[i],a=u[e]?.data;if(a){let e=r.coder.accounts.decode("binArrayBitmapExtension",a);p.set(n.toBase58(),e)}}let y=Array.from(c.values()).map(({reserveX:e,reserveY:t})=>[e,t]).flat(),g=Array.from(c.values()).map(({tokenXMint:e,tokenYMint:t})=>[e,t]).flat(),h=await ew(r.provider.connection,[...y,...g]);return await Promise.all(t.map(async(e,t)=>{let n=c.get(e.toBase58());if(!n)throw Error(`LB Pair ${e.toBase58()} state not found`);let a=p.get(e.toBase58()),s=o[t],u=null;a&&(u={account:a,publicKey:s});let m=h[2*t],g=h[2*t+1],b=h[y.length+2*t],w=h[y.length+2*t+1];if(!m||!g)throw Error(`Reserve account for LB Pair ${e.toBase58()} not found`);let f=l.p0.decode(m.data),B=l.p0.decode(g.data),P=d.qT.decode(b.data).decimals,S=d.qT.decode(w.data).decimals,M={publicKey:n.tokenXMint,reserve:n.reserveX,amount:f.amount,decimal:P},v={publicKey:n.tokenYMint,reserve:n.reserveY,amount:B.amount,decimal:S};return new eB(e,r,n,u,M,v,i)}))}static async getAllPresetParameters(e,t){let i=new m.Y7(e,{},m.Y7.defaultOptions()),n=new m.$r(B,t?.programId??P[t?.cluster??"mainnet-beta"],i);return await n.account.presetParameter.all()}static async getAllLbPairPositionsByUser(e,t,i){let n=i?.cluster||"mainnet-beta",a=new m.Y7(e,{},m.Y7.defaultOptions()),r=new m.$r(B,i?.programId??P[n],a),o=await r.account.position.all([{memcmp:{bytes:w.bs58.encode(t.toBuffer()),offset:40}}]),s=await r.account.positionV2.all([{memcmp:{bytes:w.bs58.encode(t.toBuffer()),offset:40}}]),c=new Set,p=new Set;o.forEach(({account:{upperBinId:e,lowerBinId:t,lbPair:i}})=>{let n=et(new m.BN(t)),a=et(new m.BN(e)),[o]=H(i,n,r.programId),[s]=H(i,a,r.programId);c.add(o.toBase58()),c.add(s.toBase58()),p.add(i.toBase58())});let y=Array.from(c).map(e=>new u.PublicKey(e)),g=Array.from(p).map(e=>new u.PublicKey(e)),h=new Set,b=new Set;s.forEach(({account:{upperBinId:e,lowerBinId:t,lbPair:i}})=>{let n=et(new m.BN(t)),a=et(new m.BN(e)),[o]=H(i,n,r.programId),[s]=H(i,a,r.programId);h.add(o.toBase58()),h.add(s.toBase58()),b.add(i.toBase58())});let f=Array.from(h).map(e=>new u.PublicKey(e)),S=Array.from(b).map(e=>new u.PublicKey(e)),[M,...v]=await ew(e,[u.SYSVAR_CLOCK_PUBKEY,...y,...g,...f,...S]),k=new Map;for(let e=0;e<y.length;e++){let t=y[e],i=v[e];if(!i)throw Error(`Bin Array account ${t.toBase58()} not found`);let n=r.coder.accounts.decode("binArray",i.data);k.set(t.toBase58(),n)}let I=new Map;for(let e=y.length;e<y.length+g.length;e++){let t=g[e-y.length],i=v[e];if(!i)throw Error(`LB Pair account ${t.toBase58()} not found`);let n=r.coder.accounts.decode("lbPair",i.data);I.set(t.toBase58(),n)}let A=Array.from(I.values()).map(({reserveX:e,reserveY:t,tokenXMint:i,tokenYMint:n})=>[e,t,i,n]).flat(),N=new Map;for(let e=y.length+g.length;e<y.length+g.length+f.length;e++){let t=f[e-(y.length+g.length)],i=v[e];if(!i)throw Error(`Bin Array account ${t.toBase58()} not found`);let n=r.coder.accounts.decode("binArray",i.data);N.set(t.toBase58(),n)}let x=new Map;for(let e=y.length+g.length+f.length;e<v.length;e++){let t=S[e-(y.length+g.length+f.length)],i=v[e];if(!i)throw Error(`LB Pair account ${t.toBase58()} not found`);let n=r.coder.accounts.decode("lbPair",i.data);x.set(t.toBase58(),n)}let Y=Array.from(x.values()).map(({reserveX:e,reserveY:t,tokenXMint:i,tokenYMint:n})=>[e,t,i,n]).flat(),X=await ew(r.provider.connection,[...A,...Y]),T=new Map,K=new Map;g.forEach((e,t)=>{let i=4*t,n=X[i],a=X[i+1];if(!n||!a)throw Error(`Reserve account for LB Pair ${e.toBase58()} not found`);let r=l.p0.decode(n.data),o=l.p0.decode(a.data);T.set(e.toBase58(),{reserveX:r.amount,reserveY:o.amount});let s=X[i+2],u=X[i+3];if(!s||!u)throw Error(`Mint account for LB Pair ${e.toBase58()} not found`);let m=d.qT.decode(s.data),c=d.qT.decode(u.data);K.set(e.toBase58(),{mintXDecimal:m.decimals,mintYDecimal:c.decimals})});let L=new Map,E=new Map;S.forEach((e,t)=>{let i=4*t,n=X[A.length+i],a=X[A.length+i+1];if(!n||!a)throw Error(`Reserve account for LB Pair ${e.toBase58()} not found`);let r=l.p0.decode(n.data),o=l.p0.decode(a.data);L.set(e.toBase58(),{reserveX:r.amount,reserveY:o.amount});let s=X[A.length+i+2],u=X[A.length+i+3];if(!s||!u)throw Error(`Mint account for LB Pair ${e.toBase58()} not found`);let m=d.qT.decode(s.data),c=d.qT.decode(u.data);E.set(e.toBase58(),{mintXDecimal:m.decimals,mintYDecimal:c.decimals})});let O=new m.BN(M.data.readBigInt64LE(32).toString()).toNumber(),_=new Map;for(let e of o){let{account:t,publicKey:i}=e,{upperBinId:n,lowerBinId:a,lbPair:o}=t,s=et(new m.BN(a)),d=et(new m.BN(n)),[l]=H(o,s,r.programId),[c]=H(o,d,r.programId),p=k.get(l.toBase58()),y=k.get(c.toBase58()),g=I.get(o.toBase58()),{mintXDecimal:h,mintYDecimal:b}=K.get(o.toBase58()),w=T.get(o.toBase58())?.reserveX??BigInt(0),f=T.get(o.toBase58())?.reserveY??BigInt(0),B={publicKey:g.tokenXMint,reserve:g.reserveX,amount:w,decimal:h},P={publicKey:g.tokenYMint,reserve:g.reserveY,amount:f,decimal:b},S=await eB.processPosition(r,0,g,O,t,h,b,p,y,u.PublicKey.default);S&&_.set(o.toBase58(),{publicKey:o,lbPair:g,tokenX:B,tokenY:P,lbPairPositionsData:[..._.get(o.toBase58())?.lbPairPositionsData??[],{publicKey:i,positionData:S,version:0}]})}for(let e of s){let{account:t,publicKey:i}=e,{upperBinId:n,lowerBinId:a,lbPair:o,feeOwner:s}=t,u=et(new m.BN(a)),d=et(new m.BN(n)),[l]=H(o,u,r.programId),[c]=H(o,d,r.programId),p=N.get(l.toBase58()),y=N.get(c.toBase58()),g=x.get(o.toBase58()),[h,b]=await Promise.all([ey(r.provider.connection,g.tokenXMint),ey(r.provider.connection,g.tokenYMint)]),w=L.get(o.toBase58())?.reserveX??BigInt(0),f=L.get(o.toBase58())?.reserveY??BigInt(0),B={publicKey:g.tokenXMint,reserve:g.reserveX,amount:w,decimal:h},P={publicKey:g.tokenYMint,reserve:g.reserveY,amount:f,decimal:b},S=await eB.processPosition(r,1,g,O,t,h,b,p,y,s);S&&_.set(o.toBase58(),{publicKey:o,lbPair:g,tokenX:B,tokenY:P,lbPairPositionsData:[..._.get(o.toBase58())?.lbPairPositionsData??[],{publicKey:i,positionData:S,version:1}]})}return _}static async migratePosition(e,t,i,n,a){let r=a?.cluster||"mainnet-beta",o=new m.Y7(e,{},m.Y7.defaultOptions()),s=new m.$r(B,a?.programId??P[r],o),d=await s.account.position.fetchMultiple(t),{blockhash:l,lastValidBlockHeight:c}=await e.getLatestBlockhash("confirmed");return Promise.all(d.map(async({lbPair:e,lowerBinId:a},r)=>{let o=t[r],d=et(new m.BN(a)),p=d.add(new m.BN(1)),[y]=H(e,d,s.programId),[g]=H(e,p,s.programId),h=await s.methods.migratePosition().accounts({binArrayLower:y,binArrayUpper:g,lbPair:e,owner:n,positionV1:o,positionV2:i[r],program:s.programId,rentReceiver:n,systemProgram:u.SystemProgram.programId}).transaction();return new u.Transaction({blockhash:l,lastValidBlockHeight:c,feePayer:n}).add(h)}))}static getPricePerLamport(e,t,i){return new h.Z(i).mul(new h.Z(10**(t-e))).toString()}static getBinIdFromPrice(e,t,i){let n=new h.Z(t).div(new h.Z(1e4)),a=new h.Z(e).log().dividedBy(new h.Z(1).add(n).log());return(i?a.floor():a.ceil()).toNumber()}static async createPermissionLbPair(e,t,i,n,a,r,o,s,d,l){let c=new m.Y7(e,{},m.Y7.defaultOptions()),p=new m.$r(B,l?.programId??P[l.cluster],c),[g]=function(e,t,i,n,a){let[r,o]=C(t,i);return u.PublicKey.findProgramAddressSync([e.toBuffer(),r.toBuffer(),o.toBuffer(),new Uint8Array(n.toArrayLike(f,"le",2))],a)}(r,i,n,t,p.programId),[b]=$(i,g,p.programId),[w]=$(n,g,p.programId),[S]=V(g,p.programId),M=Q(et(a))?ee(g,p.programId)[0]:null,{minBinId:v,maxBinId:k}=function(e){let t=1+e.toNumber()/1e4,i=new h.Z("18446744073709551615").log(10).div(new h.Z(t).log(10)).floor(),n=new m.BN(i.neg().toString()),a=new m.BN(i.toString()),r=new m.BN(1),o=new m.BN("340282366920938463463374607431768211455");for(;;){let t=D(n,e);if(t.gt(r)&&!t.isZero())break;n=n.add(new m.BN(1))}for(;;){let t=D(a,e);if(t.lt(o)&&!t.isZero())break;a=a.sub(new m.BN(1))}return{minBinId:n,maxBinId:a}}(t),I={activeId:a.toNumber(),binStep:t.toNumber(),baseFactor:(function(e,t){let i=1e4*t.toNumber()/e.toNumber(),n=Math.floor(i);if(i!=n){if(n>=65535)throw"base factor for the give fee bps overflow u16";if(0==n)throw"base factor for the give fee bps underflow";if(i%1!=0)throw"couldn't compute base factor for the exact fee bps"}return new m.BN(i)})(t,s).toNumber(),minBinId:v.toNumber(),maxBinId:k.toNumber(),lockDurationInSlot:d};return p.methods.initializePermissionLbPair(I).accounts({lbPair:g,rent:u.SYSVAR_RENT_PUBKEY,reserveX:b,reserveY:w,binArrayBitmapExtension:M,tokenMintX:i,tokenMintY:n,tokenProgram:y.H_,oracle:S,systemProgram:u.SystemProgram.programId,admin:o,base:r}).transaction()}static async createLbPair(e,t,i,n,a,r,o,s,d){let l=new m.Y7(e,{},m.Y7.defaultOptions()),c=new m.$r(B,d?.programId??P[d.cluster],l);if(await this.getPairPubkeyIfExists(e,i,n,a,r))throw Error("Pool already exists");let[p]=z(i,n,a,r,c.programId),[g]=$(i,p,c.programId),[h]=$(n,p,c.programId),[b]=V(p,c.programId),w=Q(et(s))?ee(p,c.programId)[0]:null;return c.methods.initializeLbPair(s.toNumber(),a.toNumber()).accounts({funder:t,lbPair:p,rent:u.SYSVAR_RENT_PUBKEY,reserveX:g,reserveY:h,binArrayBitmapExtension:w,tokenMintX:i,tokenMintY:n,tokenProgram:y.H_,oracle:b,presetParameter:o,systemProgram:u.SystemProgram.programId}).transaction()}async refetchStates(){let e=ee(this.pubkey,this.program.programId)[0],[t,i,n,a]=await ew(this.program.provider.connection,[this.pubkey,e,this.lbPair.reserveX,this.lbPair.reserveY]),r=this.program.coder.accounts.decode("lbPair",t.data);if(i){let t=this.program.coder.accounts.decode("binArrayBitmapExtension",i.data);t&&(this.binArrayBitmapExtension={account:t,publicKey:e})}let o=l.p0.decode(n.data),s=l.p0.decode(a.data),[u,m]=await Promise.all([ey(this.program.provider.connection,r.tokenXMint),ey(this.program.provider.connection,r.tokenYMint)]);this.tokenX={amount:o.amount,decimal:u,publicKey:r.tokenXMint,reserve:r.reserveX},this.tokenY={amount:s.amount,decimal:m,publicKey:r.tokenYMint,reserve:r.reserveY},this.lbPair=r}async getBinArrays(){return this.program.account.binArray.all([{memcmp:{bytes:w.bs58.encode(this.pubkey.toBuffer()),offset:24}}])}async getBinArrayForSwap(e,t=4){await this.refetchStates();let i=new Set,n=!1,a=this.lbPair.activeId;for(;!n;){let r=er(e,new m.BN(a),this.lbPair,this.binArrayBitmapExtension?.account??null);if(null===r)n=!0;else{let[t]=H(this.pubkey,r,this.program.programId);i.add(t.toBase58());let[n,o]=ei(r);a=e?n.toNumber()-1:o.toNumber()+1}i.size===t&&(n=!0)}let r=Array.from(i).map(e=>new u.PublicKey(e)),o=await ew(this.program.provider.connection,r);return await Promise.all(o.map(async(e,t)=>({account:this.program.coder.accounts.decode("binArray",e.data),publicKey:r[t]})))}static calculateFeeInfo(e,t){let i=new m.BN(e).mul(new m.BN(t)).mul(new m.BN(10));return{baseFeeRatePercentage:new h.Z(i.toString()).mul(new h.Z(100)).div(new h.Z(M.toString())),maxFeeRatePercentage:new h.Z(v.toString()).mul(new h.Z(100)).div(new h.Z(M.toString()))}}getFeeInfo(){let{baseFactor:e,protocolShare:t}=this.lbPair.parameters,{baseFeeRatePercentage:i,maxFeeRatePercentage:n}=eB.calculateFeeInfo(e,this.lbPair.binStep);return{baseFeeRatePercentage:i,maxFeeRatePercentage:n,protocolFeePercentage:new h.Z(t.toString()).mul(new h.Z(100)).div(new h.Z(1e4))}}getDynamicFee(){let e=Object.assign({},this.lbPair.vParameters),t=new m.BN(this.lbPair.activeId),i=this.lbPair.parameters,n=Date.now()/1e3;this.updateReference(t.toNumber(),e,i,n),this.updateVolatilityAccumulator(e,i,t.toNumber());let a=es(this.lbPair.binStep,i,e);return new h.Z(a.toString()).div(new h.Z(M.toString())).mul(100)}getEmissionRate(){let[e,t]=this.lbPair.rewardInfos.map(({rewardRate:e})=>e);return{rewardOne:new h.Z(e.toString()).div(18446744073709552e3),rewardTwo:new h.Z(t.toString()).div(18446744073709552e3)}}async getBinsAroundActiveBin(e,t){let i=this.lbPair.activeId-e-1,n=this.lbPair.activeId+t+1,a=await this.getBins(this.pubkey,i,n,this.tokenX.decimal,this.tokenY.decimal);return{activeBin:this.lbPair.activeId,bins:a}}async getBinsBetweenMinAndMaxPrice(e,t){let i=this.getBinIdFromPrice(e,!0)-1,n=this.getBinIdFromPrice(t,!1)+1,a=await this.getBins(this.pubkey,i,n,this.tokenX.decimal,this.tokenX.decimal);return{activeBin:this.lbPair.activeId,bins:a}}async getBinsBetweenLowerAndUpperBound(e,t,i,n){let a=await this.getBins(this.pubkey,e,t,this.tokenX.decimal,this.tokenY.decimal,i,n);return{activeBin:this.lbPair.activeId,bins:a}}toPricePerLamport(e){return eB.getPricePerLamport(this.tokenX.decimal,this.tokenY.decimal,e)}fromPricePerLamport(e){return new h.Z(e).div(new h.Z(10**(this.tokenY.decimal-this.tokenX.decimal))).toString()}async getActiveBin(){let{activeId:e}=await this.program.account.lbPair.fetch(this.pubkey),[t]=await this.getBins(this.pubkey,e,e,this.tokenX.decimal,this.tokenY.decimal);return t}getPriceOfBinByBinId(e){let t=new h.Z(this.lbPair.binStep).div(new h.Z(1e4));return new h.Z(1).add(new h.Z(t)).pow(new h.Z(e)).toString()}getBinIdFromPrice(e,t){return eB.getBinIdFromPrice(e,this.lbPair.binStep,t)}async getPositionsByUserAndLbPair(e){let[t,i,n]=await Promise.all([this.getActiveBin(),e&&this.program.account.position.all([{memcmp:{bytes:w.bs58.encode(e.toBuffer()),offset:40}},{memcmp:{bytes:w.bs58.encode(this.pubkey.toBuffer()),offset:8}}]),e&&this.program.account.positionV2.all([{memcmp:{bytes:w.bs58.encode(e.toBuffer()),offset:40}},{memcmp:{bytes:w.bs58.encode(this.pubkey.toBuffer()),offset:8}}])]);if(!t)throw Error("Error fetching active bin");if(!e)return{activeBin:t,userPositions:[]};if(!i||!n)throw Error("Error fetching positions");let a=new Set;i.forEach(({account:{upperBinId:e,lowerBinId:t}})=>{let i=et(new m.BN(t)),n=et(new m.BN(e)),[r]=H(this.pubkey,i,this.program.programId),[o]=H(this.pubkey,n,this.program.programId);a.add(r.toBase58()),a.add(o.toBase58())});let r=Array.from(a).map(e=>new u.PublicKey(e)),o=new Set;n.forEach(({account:{upperBinId:e,lowerBinId:t,lbPair:i}})=>{let n=et(new m.BN(t)),a=et(new m.BN(e)),[r]=H(this.pubkey,n,this.program.programId),[s]=H(this.pubkey,a,this.program.programId);o.add(r.toBase58()),o.add(s.toBase58())});let s=Array.from(o).map(e=>new u.PublicKey(e)),[d,l,...c]=await ew(this.program.provider.connection,[this.pubkey,u.SYSVAR_CLOCK_PUBKEY,...r,...s]),p=new Map;for(let e=0;e<r.length;e++){let t=r[e],i=c[e];if(!i)throw Error(`Bin Array account ${t.toBase58()} not found`);let n=this.program.coder.accounts.decode("binArray",i.data);p.set(t.toBase58(),n)}let y=new Map;for(let e=r.length;e<c.length;e++){let t=s[e-r.length],i=c[e];if(!i)throw Error(`Bin Array account ${t.toBase58()} not found`);let n=this.program.coder.accounts.decode("binArray",i.data);y.set(t.toBase58(),n)}if(!d)throw Error(`LB Pair account ${this.pubkey.toBase58()} not found`);let g=new m.BN(l.data.readBigInt64LE(32).toString()).toNumber();return{activeBin:t,userPositions:[...await Promise.all(i.map(async({publicKey:e,account:t})=>{let{lowerBinId:i,upperBinId:n}=t,a=et(new m.BN(i)),r=et(new m.BN(n)),[o]=H(this.pubkey,a,this.program.programId),[s]=H(this.pubkey,r,this.program.programId),d=p.get(o.toBase58()),l=p.get(s.toBase58());return{publicKey:e,positionData:await eB.processPosition(this.program,0,this.lbPair,g,t,this.tokenX.decimal,this.tokenY.decimal,d,l,u.PublicKey.default),version:0}})),...await Promise.all(n.map(async({publicKey:e,account:t})=>{let{lowerBinId:i,upperBinId:n,feeOwner:a}=t,r=et(new m.BN(i)),o=et(new m.BN(n)),[s]=H(this.pubkey,r,this.program.programId),[u]=H(this.pubkey,o,this.program.programId),d=y.get(s.toBase58()),l=y.get(u.toBase58());return{publicKey:e,positionData:await eB.processPosition(this.program,1,this.lbPair,g,t,this.tokenX.decimal,this.tokenY.decimal,d,l,a),version:1}}))]}}async quoteCreatePosition({strategy:e}){let{minBinId:t,maxBinId:i}=e,n=et(new m.BN(t)),a=et(new m.BN(i)),r=(await this.binArraysToBeCreate(n,a)).length,o=Math.ceil((i-t+1)/69);return{binArraysCount:r,binArrayCost:.07054656*r,positionCount:o,positionCost:.0565152*o}}async initializePositionAndAddLiquidityByStrategy({positionPubKey:e,totalXAmount:t,totalYAmount:i,strategy:n,user:a,slippage:r}){let{maxBinId:o,minBinId:s}=n,d=r?Math.ceil(r/(this.lbPair.binStep/100)):3,l=[ef()],c=await this.program.methods.initializePosition(s,o-s+1).accounts({payer:a,position:e,lbPair:this.pubkey,owner:a}).instruction();l.push(c);let p=et(new m.BN(s)),[g]=H(this.pubkey,p,this.program.programId),h=m.BN.max(p.add(new m.BN(1)),et(new m.BN(o))),[b]=H(this.pubkey,h,this.program.programId),w=await this.createBinArraysIfNeeded(h,p,a);l.push(...w);let[{ataPubKey:f,ix:B},{ataPubKey:P,ix:S}]=await Promise.all([eg(this.program.provider.connection,this.tokenX.publicKey,a),eg(this.program.provider.connection,this.tokenY.publicKey,a)]);if(B&&l.push(B),S&&l.push(S),this.tokenX.publicKey.equals(y.Gd)&&!t.isZero()){let e=eh(a,f,BigInt(t.toString()));l.push(...e)}if(this.tokenY.publicKey.equals(y.Gd)&&!i.isZero()){let e=eh(a,P,BigInt(i.toString()));l.push(...e)}let M=[];if([this.tokenX.publicKey.toBase58(),this.tokenY.publicKey.toBase58()].includes(y.Gd.toBase58())){let e=await eb(a);e&&M.push(e)}let v=et(new m.BN(s)),k=et(new m.BN(o)),I=Q(v)||Q(k)?ee(this.pubkey,this.program.programId)[0]:null,A=this.lbPair.activeId,N=el(n),x={position:e,lbPair:this.pubkey,userTokenX:f,userTokenY:P,reserveX:this.lbPair.reserveX,reserveY:this.lbPair.reserveY,tokenXMint:this.lbPair.tokenXMint,tokenYMint:this.lbPair.tokenYMint,binArrayLower:g,binArrayUpper:b,binArrayBitmapExtension:I,sender:a,tokenXProgram:y.H_,tokenYProgram:y.H_},Y={amount:t.isZero()?i:t,activeId:A,maxActiveBinSlippage:d,strategyParameters:N},X={binArrayLower:g,binArrayUpper:b,lbPair:this.pubkey,binArrayBitmapExtension:null,sender:a,position:e,reserve:t.isZero()?this.lbPair.reserveY:this.lbPair.reserveX,tokenMint:t.isZero()?this.lbPair.tokenYMint:this.lbPair.tokenXMint,tokenProgram:y.H_,userToken:t.isZero()?P:f},T=t.isZero()||i.isZero(),K=T?this.program.methods.addLiquidityByStrategyOneSide(Y):this.program.methods.addLiquidityByStrategy({amountX:t,amountY:i,activeId:A,maxActiveBinSlippage:d,strategyParameters:N}),L=await K.accounts(T?X:x).preInstructions(l).postInstructions(M).transaction(),{blockhash:E,lastValidBlockHeight:O}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:E,lastValidBlockHeight:O,feePayer:a}).add(L)}async initializePositionAndAddLiquidityByWeight({positionPubKey:e,totalXAmount:t,totalYAmount:i,xYAmountDistribution:n,user:a,slippage:r}){let{lowerBinId:o,upperBinId:s,binIds:d}=this.processXYAmountDistribution(n),l=r?Math.ceil(r/(this.lbPair.binStep/100)):3;if(s>=o+A.toNumber())throw Error(`Position must be within a range of 1 to ${A.toNumber()} bins.`);let c=[],p=await this.program.methods.initializePosition(o,s-o+1).accounts({payer:a,position:e,lbPair:this.pubkey,owner:a}).instruction();c.push(p);let g=et(new m.BN(o)),[h]=H(this.pubkey,g,this.program.programId),b=m.BN.max(g.add(new m.BN(1)),et(new m.BN(s))),[w]=H(this.pubkey,b,this.program.programId),f=await this.createBinArraysIfNeeded(b,g,a);c.push(...f);let[{ataPubKey:B,ix:P},{ataPubKey:S,ix:M}]=await Promise.all([eg(this.program.provider.connection,this.tokenX.publicKey,a),eg(this.program.provider.connection,this.tokenY.publicKey,a)]);if(P&&c.push(P),M&&c.push(M),this.tokenX.publicKey.equals(y.Gd)&&!t.isZero()){let e=eh(a,B,BigInt(t.toString()));c.push(...e)}if(this.tokenY.publicKey.equals(y.Gd)&&!i.isZero()){let e=eh(a,S,BigInt(i.toString()));c.push(...e)}let v=[];if([this.tokenX.publicKey.toBase58(),this.tokenY.publicKey.toBase58()].includes(y.Gd.toBase58())){let e=await eb(a);e&&v.push(e)}let k=ef(),I=et(new m.BN(Math.min(...d))),N=et(new m.BN(Math.max(...d))),x=Q(I)||Q(N)?ee(this.pubkey,this.program.programId)[0]:null,Y=this.lbPair.activeId,X=q(t,i,n.map(e=>({binId:e.binId,xAmountBpsOfTotal:e.xAmountBpsOfTotal,yAmountBpsOfTotal:e.yAmountBpsOfTotal})),this.lbPair.binStep);if(0===X.length)throw Error("No liquidity to add");let T={position:e,lbPair:this.pubkey,userTokenX:B,userTokenY:S,reserveX:this.lbPair.reserveX,reserveY:this.lbPair.reserveY,tokenXMint:this.lbPair.tokenXMint,tokenYMint:this.lbPair.tokenYMint,binArrayLower:h,binArrayUpper:w,binArrayBitmapExtension:x,sender:a,tokenXProgram:y.H_,tokenYProgram:y.H_},K={amount:t.isZero()?i:t,activeId:Y,maxActiveBinSlippage:l,binLiquidityDist:X},L={binArrayLower:h,binArrayUpper:w,lbPair:this.pubkey,binArrayBitmapExtension:null,sender:a,position:e,reserve:t.isZero()?this.lbPair.reserveY:this.lbPair.reserveX,tokenMint:t.isZero()?this.lbPair.tokenYMint:this.lbPair.tokenXMint,tokenProgram:y.H_,userToken:t.isZero()?S:B},E=t.isZero()||i.isZero(),O=E?this.program.methods.addLiquidityOneSide(K):this.program.methods.addLiquidityByWeight({amountX:t,amountY:i,binLiquidityDist:X,activeId:Y,maxActiveBinSlippage:l});if(n.length<26){let e=await O.accounts(E?L:T).preInstructions([k,...c]).postInstructions(v).transaction(),{blockhash:t,lastValidBlockHeight:i}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:t,lastValidBlockHeight:i,feePayer:a}).add(e)}let _=await O.accounts(E?L:T).preInstructions([k]).transaction(),Z=[],{blockhash:R,lastValidBlockHeight:F}=await this.program.provider.connection.getLatestBlockhash("confirmed");if(c.length){let e=new u.Transaction({blockhash:R,lastValidBlockHeight:F,feePayer:a}).add(...c);Z.push(e)}let D=new u.Transaction({blockhash:R,lastValidBlockHeight:F,feePayer:a}).add(_);if(Z.push(D),v.length){let e=new u.Transaction({blockhash:R,lastValidBlockHeight:F,feePayer:a}).add(...v);Z.push(e)}return Z}async addLiquidityByStrategy({positionPubKey:e,totalXAmount:t,totalYAmount:i,strategy:n,user:a,slippage:r}){let{maxBinId:o,minBinId:s}=n,d=r?Math.ceil(r/(this.lbPair.binStep/100)):3,l=[],c=ef();l.push(c);let p=et(new m.BN(s)),g=et(new m.BN(o)),h=Q(p)||Q(g)?ee(this.pubkey,this.program.programId)[0]:null,b=this.lbPair.activeId,w=el(n),f=et(new m.BN(s)),[B]=H(this.pubkey,f,this.program.programId),P=m.BN.max(f.add(new m.BN(1)),et(new m.BN(o))),[S]=H(this.pubkey,P,this.program.programId),M=await this.createBinArraysIfNeeded(P,f,a);l.push(...M);let[{ataPubKey:v,ix:k},{ataPubKey:I,ix:A}]=await Promise.all([eg(this.program.provider.connection,this.tokenX.publicKey,a),eg(this.program.provider.connection,this.tokenY.publicKey,a)]);if(k&&l.push(k),A&&l.push(A),this.tokenX.publicKey.equals(y.Gd)&&!t.isZero()){let e=eh(a,v,BigInt(t.toString()));l.push(...e)}if(this.tokenY.publicKey.equals(y.Gd)&&!i.isZero()){let e=eh(a,I,BigInt(i.toString()));l.push(...e)}let N=[];if([this.tokenX.publicKey.toBase58(),this.tokenY.publicKey.toBase58()].includes(y.Gd.toBase58())){let e=await eb(a);e&&N.push(e)}let x={amountX:t,amountY:i,activeId:this.lbPair.activeId,maxActiveBinSlippage:d,strategyParameters:w},Y={position:e,lbPair:this.pubkey,userTokenX:v,userTokenY:I,reserveX:this.lbPair.reserveX,reserveY:this.lbPair.reserveY,tokenXMint:this.lbPair.tokenXMint,tokenYMint:this.lbPair.tokenYMint,binArrayLower:B,binArrayUpper:S,binArrayBitmapExtension:h,sender:a,tokenXProgram:y.H_,tokenYProgram:y.H_},X={amount:t.isZero()?i:t,activeId:b,maxActiveBinSlippage:d,strategyParameters:w},T={binArrayLower:B,binArrayUpper:S,lbPair:this.pubkey,binArrayBitmapExtension:null,sender:a,position:e,reserve:t.isZero()?this.lbPair.reserveY:this.lbPair.reserveX,tokenMint:t.isZero()?this.lbPair.tokenYMint:this.lbPair.tokenXMint,tokenProgram:y.H_,userToken:t.isZero()?I:v},K=t.isZero()||i.isZero(),L=K?this.program.methods.addLiquidityByStrategyOneSide(X):this.program.methods.addLiquidityByStrategy(x),E=await L.accounts(K?T:Y).preInstructions(l).postInstructions(N).transaction(),{blockhash:O,lastValidBlockHeight:_}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:O,lastValidBlockHeight:_,feePayer:a}).add(E)}async addLiquidityByWeight({positionPubKey:e,totalXAmount:t,totalYAmount:i,xYAmountDistribution:n,user:a,slippage:r}){let o=r?Math.ceil(r/(this.lbPair.binStep/100)):3,s=await this.program.account.positionV2.fetch(e),{lowerBinId:d,upperBinId:l,binIds:c}=this.processXYAmountDistribution(n);if(d<s.lowerBinId)throw Error(`Lower Bin ID (${d}) lower than Position Lower Bin Id (${s.lowerBinId})`);if(l>s.upperBinId)throw Error(`Upper Bin ID (${l}) higher than Position Upper Bin Id (${s.upperBinId})`);let p=et(new m.BN(Math.min(...c))),g=et(new m.BN(Math.max(...c))),h=Q(p)||Q(g)?ee(this.pubkey,this.program.programId)[0]:null,b=this.lbPair.activeId,w=q(t,i,n.map(e=>({binId:e.binId,xAmountBpsOfTotal:e.xAmountBpsOfTotal,yAmountBpsOfTotal:e.yAmountBpsOfTotal})),this.lbPair.binStep);if(0===w.length)throw Error("No liquidity to add");let f=et(new m.BN(s.lowerBinId)),[B]=H(this.pubkey,f,this.program.programId),P=m.BN.max(f.add(new m.BN(1)),et(new m.BN(s.upperBinId))),[S]=H(this.pubkey,P,this.program.programId),M=[],v=await this.createBinArraysIfNeeded(P,f,a);M.push(...v);let[{ataPubKey:k,ix:I},{ataPubKey:A,ix:N}]=await Promise.all([eg(this.program.provider.connection,this.tokenX.publicKey,a),eg(this.program.provider.connection,this.tokenY.publicKey,a)]);if(I&&M.push(I),N&&M.push(N),this.tokenX.publicKey.equals(y.Gd)&&!t.isZero()){let e=eh(a,k,BigInt(t.toString()));M.push(...e)}if(this.tokenY.publicKey.equals(y.Gd)&&!i.isZero()){let e=eh(a,A,BigInt(i.toString()));M.push(...e)}let x=[];if([this.tokenX.publicKey.toBase58(),this.tokenY.publicKey.toBase58()].includes(y.Gd.toBase58())){let e=await eb(a);e&&x.push(e)}let Y=ef(),X={position:e,lbPair:this.pubkey,userTokenX:k,userTokenY:A,reserveX:this.lbPair.reserveX,reserveY:this.lbPair.reserveY,tokenXMint:this.lbPair.tokenXMint,tokenYMint:this.lbPair.tokenYMint,binArrayLower:B,binArrayUpper:S,binArrayBitmapExtension:h,sender:a,tokenXProgram:y.H_,tokenYProgram:y.H_},T={amount:t.isZero()?i:t,activeId:b,maxActiveBinSlippage:o,binLiquidityDist:w},K={binArrayLower:B,binArrayUpper:S,lbPair:this.pubkey,binArrayBitmapExtension:null,sender:a,position:e,reserve:t.isZero()?this.lbPair.reserveY:this.lbPair.reserveX,tokenMint:t.isZero()?this.lbPair.tokenYMint:this.lbPair.tokenXMint,tokenProgram:y.H_,userToken:t.isZero()?A:k},L=t.isZero()||i.isZero(),E=L?this.program.methods.addLiquidityOneSide(T):this.program.methods.addLiquidityByWeight({amountX:t,amountY:i,binLiquidityDist:w,activeId:b,maxActiveBinSlippage:o});if(n.length<26){let e=await E.accounts(L?K:X).preInstructions([Y,...M]).postInstructions(x).transaction(),{blockhash:t,lastValidBlockHeight:i}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:t,lastValidBlockHeight:i,feePayer:a}).add(e)}let O=await E.accounts(L?K:X).preInstructions([Y]).transaction(),_=[],{blockhash:Z,lastValidBlockHeight:R}=await this.program.provider.connection.getLatestBlockhash("confirmed");if(M.length){let e=new u.Transaction({blockhash:Z,lastValidBlockHeight:R,feePayer:a}).add(...M);_.push(e)}let F=new u.Transaction({blockhash:Z,lastValidBlockHeight:R,feePayer:a}).add(O);if(_.push(F),x.length){let e=new u.Transaction({blockhash:Z,lastValidBlockHeight:R,feePayer:a}).add(...x);_.push(e)}return _}async removeLiquidity({user:e,position:t,binIds:i,bps:n,shouldClaimAndClose:a=!1}){let{lbPair:r,lowerBinId:o,owner:s,feeOwner:d}=await this.program.account.positionV2.fetch(t),{reserveX:l,reserveY:c,tokenXMint:p,tokenYMint:g}=await this.program.account.lbPair.fetch(r),h=et(new m.BN(o)),b=h.add(new m.BN(1)),[w]=H(r,h,this.program.programId),[f]=H(r,b,this.program.programId),B=[],P=ef();B.push(P);let S=d.equals(u.PublicKey.default)?e:d,[{ataPubKey:M,ix:v},{ataPubKey:k,ix:I},{ataPubKey:A,ix:N},{ataPubKey:x,ix:Y}]=await Promise.all([eg(this.program.provider.connection,this.tokenX.publicKey,s,e),eg(this.program.provider.connection,this.tokenY.publicKey,s,e),eg(this.program.provider.connection,this.tokenX.publicKey,S,e),eg(this.program.provider.connection,this.tokenY.publicKey,S,e)]);v&&B.push(v),I&&B.push(I),!S.equals(s)&&(N&&B.push(N),Y&&B.push(Y));let X=[],T=[];if(a){let i=await this.program.methods.claimFee().accounts({binArrayLower:w,binArrayUpper:f,lbPair:this.pubkey,sender:e,position:t,reserveX:l,reserveY:c,tokenProgram:y.H_,tokenXMint:this.tokenX.publicKey,tokenYMint:this.tokenY.publicKey,userTokenX:A,userTokenY:x}).instruction();T.push(i);for(let i=0;i<2;i++){let n=this.lbPair.rewardInfos[i];if(!n||n.mint.equals(u.PublicKey.default))continue;let{ataPubKey:a,ix:r}=await eg(this.program.provider.connection,n.mint,e);r&&B.push(r);let o=await this.program.methods.claimReward(new m.BN(i)).accounts({lbPair:this.pubkey,sender:e,position:t,binArrayLower:w,binArrayUpper:f,rewardVault:n.vault,rewardMint:n.mint,tokenProgram:y.H_,userTokenAccount:a}).instruction();X.push(o)}let n=await this.program.methods.closePosition().accounts({binArrayLower:w,binArrayUpper:f,rentReceiver:s,position:t,lbPair:this.pubkey,sender:e}).instruction();X.length?X.push(n):T.push(n)}if([this.tokenX.publicKey.toBase58(),this.tokenY.publicKey.toBase58()].includes(y.Gd.toBase58())){let t=await eb(e);t&&T.push(t)}let K=Math.min(...i),L=Math.max(...i),E=et(new m.BN(K)),O=et(new m.BN(L)),_=Q(E)||Q(O)?ee(this.pubkey,this.program.programId)[0]:null,q=await this.program.methods.removeLiquidityByRange(K,L,n.toNumber()).accounts({position:t,lbPair:r,userTokenX:M,userTokenY:k,reserveX:l,reserveY:c,tokenXMint:p,tokenYMint:g,binArrayLower:w,binArrayUpper:f,binArrayBitmapExtension:_,tokenXProgram:y.H_,tokenYProgram:y.H_,sender:e}).preInstructions(B).postInstructions(T).transaction(),{blockhash:Z,lastValidBlockHeight:R}=await this.program.provider.connection.getLatestBlockhash("confirmed");if(!X.length)return new u.Transaction({blockhash:Z,lastValidBlockHeight:R,feePayer:e}).add(q);{let t=new u.Transaction({blockhash:Z,lastValidBlockHeight:R,feePayer:e}).add(...X);return[new u.Transaction({blockhash:Z,lastValidBlockHeight:R,feePayer:e}).add(q),t]}}async closePosition({owner:e,position:t}){let{lowerBinId:i}=await this.program.account.positionV2.fetch(t.publicKey),n=et(new m.BN(i)),[a]=H(this.pubkey,n,this.program.programId),r=n.add(new m.BN(1)),[o]=H(this.pubkey,r,this.program.programId),s=await this.program.methods.closePosition().accounts({binArrayLower:a,binArrayUpper:o,rentReceiver:e,position:t.publicKey,lbPair:this.pubkey,sender:e}).transaction(),{blockhash:d,lastValidBlockHeight:l}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:d,lastValidBlockHeight:l,feePayer:e}).add(s)}swapQuoteWithCap(e,t,i,n,a){let r=Date.now()/1e3,o=e,s=Object.assign({},this.lbPair.vParameters),u=new m.BN(this.lbPair.activeId),d=this.lbPair.binStep,l=this.lbPair.parameters;this.updateReference(u.toNumber(),s,l,r);let c=null,p=new Map,y=new m.BN(0),g=new m.BN(0),b=new m.BN(0);for(;!o.isZero();){let e=eo(t,u,this.lbPair,this.binArrayBitmapExtension?.account,a);if(null==e)throw Error("Insufficient liquidity");if(p.set(e.publicKey,!0),this.updateVolatilityAccumulator(s,l,u.toNumber()),en(u,e.account.index)){let i=ea(u.toNumber(),e.account),{isReachCap:a,amountIn:r,amountOut:m,fee:p,protocolFee:h}=function(e,t,i,n,a,r,o){var s;if((r?e.amountY:e.amountX).lt(o)){let{amountIn:o,amountOut:s,fee:u,protocolFee:m}=ed(e,t,i,n,a,r);return{isReachCap:!1,amountIn:o,amountOut:s,fee:u,protocolFee:m}}let u=(s=e.price,r?R(o,s,64,1):Z(o,s,64,1)),{amountIn:m,amountOut:d,fee:l,protocolFee:c}=ed(e,t,i,n,a.gt(u)?u:a,r);return{isReachCap:!0,amountIn:m,amountOut:d,fee:l,protocolFee:c}}(i,d,l,s,o,t,n.sub(y));if(r.isZero()||(o=o.sub(r),y=y.add(m),g=g.add(p),b=h.add(h),c||(c=i)),a)break}o.isZero()||(u=t?u.sub(new m.BN(1)):u.add(new m.BN(1)))}if(!c)throw Error("Invalid start bin");let w=ep(c,(e=e.sub(o)).sub(eu(d,l,s,e)),t),f=new h.Z(y.toString()).sub(new h.Z(w.toString())).div(new h.Z(w.toString())).mul(new h.Z(100)),B=y.mul(new m.BN(1e4).sub(i)).div(new m.BN(1e4));return{consumedInAmount:e,outAmount:y,fee:g,protocolFee:b,minOutAmount:B,priceImpact:f,binArraysPubkey:[...p.keys()]}}swapQuote(e,t,i,n){let a=Date.now()/1e3,r=e,o=Object.assign({},this.lbPair.vParameters),s=new m.BN(this.lbPair.activeId),u=this.lbPair.binStep,d=this.lbPair.parameters;this.updateReference(s.toNumber(),o,d,a);let l=null,c=new Map,p=new m.BN(0),y=new m.BN(0),g=new m.BN(0);for(;!r.isZero();){let e=eo(t,s,this.lbPair,this.binArrayBitmapExtension?.account??null,n);if(null==e)throw Error("Insufficient liquidity");if(c.set(e.publicKey,!0),this.updateVolatilityAccumulator(o,d,s.toNumber()),en(s,e.account.index)){let i=ea(s.toNumber(),e.account),{amountIn:n,amountOut:a,fee:m,protocolFee:c}=ed(i,u,d,o,r,t);n.isZero()||(r=r.sub(n),p=p.add(a),y=y.add(m),g=c.add(c),l||(l=i))}r.isZero()||(s=t?s.sub(new m.BN(1)):s.add(new m.BN(1)))}if(!l)throw Error("Invalid start bin");let b=ep(l,e.sub(eu(u,d,o,e)),t),w=new h.Z(p.toString()).sub(new h.Z(b.toString())).div(new h.Z(b.toString())).mul(new h.Z(100)),f=p.mul(new m.BN(1e4).sub(i)).div(new m.BN(1e4));return{consumedInAmount:e,outAmount:p,fee:y,protocolFee:g,minOutAmount:f,priceImpact:w,binArraysPubkey:[...c.keys()]}}async swap({inToken:e,outToken:t,inAmount:i,minOutAmount:n,lbPair:a,user:r,binArraysPubkey:o}){let{tokenXMint:s,tokenYMint:m,reserveX:d,reserveY:l,activeId:c,oracle:p}=await this.program.account.lbPair.fetch(a),g=[ef()],[{ataPubKey:h,ix:b},{ataPubKey:w,ix:f}]=await Promise.all([eg(this.program.provider.connection,e,r),eg(this.program.provider.connection,t,r)]);if(b&&g.push(b),f&&g.push(f),e.equals(y.Gd)){let e=eh(r,h,BigInt(i.toString()));g.push(...e)}let B=[];if(t.equals(y.Gd)){let e=await eb(r);e&&B.push(e)}t.equals(s);let P=o.map(e=>({isSigner:!1,isWritable:!0,pubkey:e})),S=await this.program.methods.swap(i,n).accounts({lbPair:a,reserveX:d,reserveY:l,tokenXMint:s,tokenYMint:m,tokenXProgram:y.H_,tokenYProgram:y.H_,user:r,userTokenIn:h,userTokenOut:w,binArrayBitmapExtension:this.binArrayBitmapExtension?this.binArrayBitmapExtension.publicKey:null,oracle:p,hostFeeIn:null}).remainingAccounts(P).preInstructions(g).postInstructions(B).transaction(),{blockhash:M,lastValidBlockHeight:v}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:M,lastValidBlockHeight:v,feePayer:r}).add(S)}async claimLMReward({owner:e,position:t}){let i=await this.createClaimBuildMethod({owner:e,position:t});if(!i.length)return;let{blockhash:n,lastValidBlockHeight:a}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:n,lastValidBlockHeight:a,feePayer:e}).add(...i)}async claimAllLMRewards({owner:e,positions:t}){let i=ec((await Promise.all(t.map(async(t,i)=>await this.createClaimBuildMethod({owner:e,position:t,shouldIncludePreIx:0===i})))).flat(),3),{blockhash:n,lastValidBlockHeight:a}=await this.program.provider.connection.getLatestBlockhash("confirmed");return Promise.all(i.map(async t=>new u.Transaction({feePayer:e,blockhash:n,lastValidBlockHeight:a}).add(ef()).add(...t)))}async setActivationSlot(e){let t=await this.program.methods.setActivationSlot(e).accounts({lbPair:this.pubkey,admin:this.lbPair.creator}).transaction(),{blockhash:i,lastValidBlockHeight:n}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({feePayer:this.lbPair.creator,blockhash:i,lastValidBlockHeight:n}).add(t)}async updateWhitelistedWallet(e){let t=[],i=await this.program.methods.updateWhitelistedWallet(e).accounts({lbPair:this.pubkey,creator:this.lbPair.creator}).instruction();t.push(i);let{blockhash:n,lastValidBlockHeight:a}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({feePayer:this.lbPair.creator,blockhash:n,lastValidBlockHeight:a}).add(...t)}async claimSwapFee({owner:e,position:t}){let i=await this.createClaimSwapFeeMethod({owner:e,position:t}),{blockhash:n,lastValidBlockHeight:a}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({blockhash:n,lastValidBlockHeight:a,feePayer:e}).add(i)}async claimAllSwapFee({owner:e,positions:t}){return Promise.all(ec((await Promise.all(t.map(async(i,n)=>await this.createClaimSwapFeeMethod({owner:e,position:i,shouldIncludePretIx:0===n,shouldIncludePostIx:n===t.length-1})))).flat(),3).map(async t=>{let{recentBlockhash:i,lastValidBlockHeight:n}=t[0];return new u.Transaction({feePayer:e,blockhash:i,lastValidBlockHeight:n}).add(ef()).add(...t)}))}async claimAllRewardsByPosition({owner:e,position:t}){let i=[],n=[this.tokenX.publicKey,this.tokenY.publicKey],a=[...n];for(let e=0;e<2;e++){let t=this.lbPair.rewardInfos[e].mint;a.some(e=>t.equals(e))||t.equals(u.PublicKey.default)||a.push(this.lbPair.rewardInfos[e].mint)}let r=t.positionData.feeOwner.equals(u.PublicKey.default)?e:t.positionData.feeOwner;(await Promise.all(a.map(t=>n.some(e=>e.equals(t))?eg(this.program.provider.connection,t,r,e):eg(this.program.provider.connection,t,e)))).forEach(({ix:e})=>e&&i.push(e));let o=ec([await this.createClaimSwapFeeMethod({owner:e,position:t,shouldIncludePostIx:!1,shouldIncludePretIx:!1}),...await this.createClaimBuildMethod({owner:e,position:t,shouldIncludePreIx:!1})],3),s=[];if(a.some(e=>e.equals(y.Gd))){let t=await eb(e);t&&s.push(t)}let{blockhash:m,lastValidBlockHeight:d}=await this.program.provider.connection.getLatestBlockhash("confirmed");return Promise.all(o.map(async t=>{let n=new u.Transaction({feePayer:e,blockhash:m,lastValidBlockHeight:d}).add(ef());return i.length&&n.add(...i),n.add(...t),s.length&&n.add(...s),n}))}async seedLiquidity(e,t,i,n,a,r,o,s){let u=new h.Z(10**(this.tokenY.decimal-this.tokenX.decimal)),l=new h.Z(r).mul(u),c=new h.Z(o).mul(u),p=new m.BN(eB.getBinIdFromPrice(l,this.lbPair.binStep,!1)),y=new m.BN(eB.getBinIdFromPrice(c,this.lbPair.binStep,!0));if(p.toNumber()<this.lbPair.activeId)throw Error("minPrice < current pair price");if(p.toNumber()>=y.toNumber())throw Error("Price range too small");let g=function(e,t,i,n,a,r,o){let s=new h.Z(10**(i-n)),u=_(a.toNumber(),t).mul(s),d=_(r.toNumber(),t).mul(s),l=new Map;for(let s=a.toNumber();s<r.toNumber();s++){let a=function(e,t,i,n,a,r,o,s){let u=U(e,t,i.add(new m.BN(1)),n,a,r,o,s),d=U(e,t,i,n,a,r,o,s);return new m.BN(u.sub(d).floor().toString())}(e,t,new m.BN(s),i,n,u,d,o);l.set(s,a)}return l}(n,this.lbPair.binStep,this.tokenX.decimal,this.tokenY.decimal,p,y,1/a),b=new m.BN(10**this.tokenX.decimal),{compressedBinAmount:w,compressionLoss:f}=function(e,t){let i=new Map,n=new m.BN(0),a=new m.BN(0);for(let[r,o]of e){n=n.add(o);let e=o.div(t);i.set(r,e);let s=o.sub(e.mul(t));a=a.add(s)}return{compressedBinAmount:i,compressionLoss:a}}(g,b),{newCompressedBinAmount:B,loss:P}=function(e,t,i,n){let a=new Map,r=new m.BN(0);for(let t of e.values())r=r.add(t);let o=new m.BN(0);for(let[s,u]of e.entries()){let e=u.mul(t).div(r).div(i),m=u.add(e);m.gt(n)&&(e=e.sub(m.sub(n)),m=n),a.set(s,m),o=o.add(e.mul(i))}return{newCompressedBinAmount:a,loss:t.sub(o)}}(w,f,b,new m.BN(4294967296-1)),S=y.sub(new m.BN(1)).sub(p).div(A).add(new m.BN(1)),M=(0,d.MO)(this.lbPair.tokenXMint,t,!1),v=[],k=[],I=new Set;for(let n=0;n<S.toNumber();n++){let a=p.add(A.mul(new m.BN(n))),r=a.add(A).sub(new m.BN(1)),o=et(a),u=et(r),[d,l]=W(this.pubkey,s,a,A,this.program.programId),[c]=H(this.pubkey,o,this.program.programId),[g]=H(this.pubkey,u,this.program.programId),h=await this.program.provider.connection.getMultipleAccountsInfo([c,g,d]),w=[ef()];h[0]||I.has(c.toBase58())||(w.push(await this.program.methods.initializeBinArray(o).accounts({lbPair:this.pubkey,binArray:c,funder:t}).instruction()),I.add(c.toBase58())),h[1]||I.has(g.toBase58())||(w.push(await this.program.methods.initializeBinArray(u).accounts({lbPair:this.pubkey,binArray:g,funder:t}).instruction()),I.add(g.toBase58()));let f=h[2];if(f||w.push(await this.program.methods.initializePositionByOperator(a.toNumber(),A.toNumber(),e,i).accounts({lbPair:this.pubkey,position:d,base:s,operator:t,payer:t}).instruction()),w.length>1&&(v.push(w),w=[ef()]),!(f&&this.program.coder.accounts.decode("positionV2",f.data).liquidityShares.reduce((e,t)=>e.add(t),new m.BN(0)).gt(new m.BN(0)))){let e=Math.min(r.toNumber(),y.toNumber()-1),i=[];for(let t=a.toNumber();t<=e;t++)i.push({binId:t,amount:B.get(t).toNumber()});w.push(await this.program.methods.addLiquidityOneSidePrecise({bins:i,decompressMultiplier:b}).accounts({position:d,lbPair:this.pubkey,binArrayBitmapExtension:this.binArrayBitmapExtension?this.binArrayBitmapExtension.publicKey:this.program.programId,userToken:M,reserve:this.lbPair.reserveX,tokenMint:this.lbPair.tokenXMint,binArrayLower:c,binArrayUpper:g,sender:t}).instruction()),n+1>=S.toNumber()&&!P.isZero()&&w.push(await this.program.methods.addLiquidityOneSide({amount:P,activeId:this.lbPair.activeId,maxActiveBinSlippage:0,binLiquidityDist:[{binId:e,weight:1}]}).accounts({position:d,lbPair:this.pubkey,binArrayBitmapExtension:this.binArrayBitmapExtension?this.binArrayBitmapExtension.publicKey:this.program.programId,userToken:M,reserve:this.lbPair.reserveX,tokenMint:this.lbPair.tokenXMint,binArrayLower:c,binArrayUpper:g,sender:t}).instruction()),k.push(w)}}return{initializeBinArraysAndPositionIxs:v,addLiquidityIxs:k}}async initializePositionByOperator({lowerBinId:e,positionWidth:t,owner:i,feeOwner:n,base:a,operator:r,payer:o}){let[s,m]=W(this.pubkey,a,e,t,this.program.programId),d=await this.program.methods.initializePositionByOperator(e.toNumber(),A.toNumber(),i,n).accounts({lbPair:this.pubkey,position:s,base:a,operator:r,payer:o}).transaction(),{blockhash:l,lastValidBlockHeight:c}=await this.program.provider.connection.getLatestBlockhash("confirmed");return new u.Transaction({feePayer:r,blockhash:l,lastValidBlockHeight:c}).add(d)}async claimAllRewards({owner:e,positions:t}){let i=[],n=[this.tokenX.publicKey,this.tokenY.publicKey],a=[...n];for(let e=0;e<2;e++){let t=this.lbPair.rewardInfos[e].mint;a.some(e=>t.equals(e))||t.equals(u.PublicKey.default)||a.push(this.lbPair.rewardInfos[e].mint)}let r=[...new Set([e.toBase58(),...t.filter(e=>!e.positionData.feeOwner.equals(u.PublicKey.default)).map(e=>e.positionData.feeOwner.toBase58())])].map(e=>new u.PublicKey(e));(await Promise.all(a.map(t=>n.some(e=>e.equals(t))?r.map(i=>eg(this.program.provider.connection,t,i,e)):[eg(this.program.provider.connection,t,e)]).flat())).forEach(({ix:e})=>e&&i.push(e));let o=ec([...(await Promise.all(t.map(async t=>await this.createClaimSwapFeeMethod({owner:e,position:t,shouldIncludePretIx:!1,shouldIncludePostIx:!1})))).flat(),...(await Promise.all(t.map(async t=>await this.createClaimBuildMethod({owner:e,position:t,shouldIncludePreIx:!1})))).flat()],3),s=[];if(a.some(e=>e.equals(y.Gd))){let t=await eb(e);t&&s.push(t)}let{blockhash:m,lastValidBlockHeight:d}=await this.program.provider.connection.getLatestBlockhash("confirmed");return Promise.all(o.map(async t=>{let n=new u.Transaction({feePayer:e,blockhash:m,lastValidBlockHeight:d}).add(ef());return i.length&&n.add(...i),n.add(...t),s.length&&n.add(...s),n}))}canSyncWithMarketPrice(e,t){let i=this.getBinIdFromPrice(Number(eB.getPricePerLamport(this.tokenX.decimal,this.tokenY.decimal,e)),!1),n=et(new m.BN(i)),a=i<t,r=er(a,new m.BN(t),this.lbPair,this.binArrayBitmapExtension?.account??null);return null===r||(a?n.gt(r):n.lt(r))}async syncWithMarketPrice(e,t){let i=this.getBinIdFromPrice(Number(eB.getPricePerLamport(this.tokenX.decimal,this.tokenY.decimal,e)),!1),n=(await this.getActiveBin()).binId;if(!this.canSyncWithMarketPrice(e,n))throw Error("Unable to sync with market price due to bin with liquidity between current and market price bin");let a=et(new m.BN(n)),r=er(i<n,new m.BN(n),this.lbPair,this.binArrayBitmapExtension?.account??null),o=[],[s]=ee(this.pubkey,this.program.programId);o.push(s);let[d]=H(this.pubkey,a,this.program.programId);o.push(d);let l=(()=>{if(!r)return null;let[e]=H(this.pubkey,r,this.program.programId);return o.push(e),e})(),c=await this.program.provider.connection.getMultipleAccountsInfo(o),p=null,y=null,g=null;c?.[0]&&(g=s),c?.[1]&&(p=d),c?.[2]&&r&&(y=l);let{blockhash:h,lastValidBlockHeight:b}=await this.program.provider.connection.getLatestBlockhash("confirmed"),w=await this.program.methods.goToABin(i).accounts({lbPair:this.pubkey,binArrayBitmapExtension:g,fromBinArray:p,toBinArray:y}).transaction();return new u.Transaction({feePayer:t,blockhash:h,lastValidBlockHeight:b}).add(w)}async getMaxPriceInBinArrays(e){let t;let i=e.sort(({account:{index:e}},{account:{index:t}})=>e.toNumber()-t.toNumber()),n=i.length-1;for(;n>=0;){let e=i[n];if(e){let i=e.account.bins.reverse();if(i.every(({amountX:e})=>e.isZero()))n--;else{let e=i.findLastIndex(({amountX:e})=>!e.isZero());t=i[e].price.toString(),n=-1}}}return this.fromPricePerLamport(Number(t)/(18446744073709552e3-1))}static async getBinArrays(e,t){return e.account.binArray.all([{memcmp:{bytes:w.bs58.encode(t.toBuffer()),offset:24}}])}static async getClaimableLMReward(e,t,i,n,a,r,o){let s=et(new m.BN(a.lowerBinId)),d=[new m.BN(0),new m.BN(0)],l=r,c=o;if(!r||!o){let t=et(new m.BN(a.lowerBinId)),[i]=H(a.lbPair,t,e.programId),n=t.add(new m.BN(1)),[r]=H(a.lbPair,n,e.programId);[l,c]=await e.account.binArray.fetchMultiple([i,r])}if(!l||!c)throw Error("BinArray not found");for(let e=a.lowerBinId;e<=a.upperBinId;e++){let r=et(new m.BN(e)).eq(s)?l:c,o=ea(e,r),p=e-a.lowerBinId,y=a.rewardInfos[p],g=0===t?a.liquidityShares[p]:a.liquidityShares[p].shrn(64);for(let t=0;t<2;t++){let a=i.rewardInfos[t];if(!a.mint.equals(u.PublicKey.default)){let s=o.rewardPerTokenStored[t];if(e==i.activeId&&!o.liquiditySupply.isZero()){let e=new m.BN(Math.min(n,a.rewardDurationEnd.toNumber())).sub(a.lastUpdateTime),t=0==r.version?o.liquiditySupply:o.liquiditySupply.shrn(64),i=a.rewardRate.mul(e).div(new m.BN(15)).div(t);s=s.add(i)}let u=Z(s.sub(y.rewardPerTokenCompletes[t]),g,64,1);d[t]=d[t].add(u).add(y.rewardPendings[t])}}}return{rewardOne:d[0],rewardTwo:d[1]}}static async getClaimableSwapFee(e,t,i,n,a){let r=et(new m.BN(i.lowerBinId)),o=new m.BN(0),s=new m.BN(0),u=n,d=a;if(!n||!a){let t=et(new m.BN(i.lowerBinId)),[n]=H(i.lbPair,t,e.programId),a=t.add(new m.BN(1)),[r]=H(i.lbPair,a,e.programId);[u,d]=await e.account.binArray.fetchMultiple([n,r])}if(!u||!d)throw Error("BinArray not found");for(let e=i.lowerBinId;e<=i.upperBinId;e++){let n=et(new m.BN(e)).eq(r)?u:d,a=ea(e,n),l=e-i.lowerBinId,c=i.feeInfos[l],p=0===t?i.liquidityShares[l]:i.liquidityShares[l].shrn(64),y=Z(p,a.feeAmountXPerTokenStored.sub(c.feeXPerTokenComplete),64,1),g=Z(p,a.feeAmountYPerTokenStored.sub(c.feeYPerTokenComplete),64,1);o=o.add(y).add(c.feeXPending),s=s.add(g).add(c.feeYPending)}return{feeX:o,feeY:s}}static async processPosition(e,t,i,n,a,r,o,s,u,m){let{lowerBinId:d,upperBinId:l,liquidityShares:c,lastUpdatedAt:p,totalClaimedFeeXAmount:y,totalClaimedFeeYAmount:g}=a,b=this.getBinsBetweenLowerAndUpperBound(i,d,l,r,o,s,u);if(!b.length)return null;if(b[0].binId!==d||b[b.length-1].binId!==l)throw Error("Bin ID mismatch");let w=[],f=new h.Z(0),B=new h.Z(0);b.forEach((e,i)=>{let n;let a=new h.Z(e.supply.toString());n=new h.Z(1===e.version&&0===t?c[i].shln(64).toString():c[i].toString());let r=a.eq(new h.Z("0"))?new h.Z("0"):n.mul(e.xAmount.toString()).div(a),o=a.eq(new h.Z("0"))?new h.Z("0"):n.mul(e.yAmount.toString()).div(a);f=f.add(r),B=B.add(o),w.push({binId:e.binId,price:e.price,pricePerToken:e.pricePerToken,binXAmount:e.xAmount.toString(),binYAmount:e.yAmount.toString(),binLiquidity:a.toString(),positionLiquidity:n.toString(),positionXAmount:r.toString(),positionYAmount:o.toString()})});let{feeX:P,feeY:S}=await this.getClaimableSwapFee(e,t,a,s,u),{rewardOne:M,rewardTwo:v}=await this.getClaimableLMReward(e,t,i,n,a,s,u);return{totalXAmount:f.toString(),totalYAmount:B.toString(),positionBinData:w,lastUpdatedAt:p,lowerBinId:d,upperBinId:l,feeX:P,feeY:S,rewardOne:M,rewardTwo:v,feeOwner:m,totalClaimedFeeXAmount:y,totalClaimedFeeYAmount:g}}static getBinsBetweenLowerAndUpperBound(e,t,i,n,a,r,o){let s=et(new m.BN(t)),u=et(new m.BN(i)),d=[];if(s.eq(u)){let[o]=ei(r.index);r.bins.forEach((s,u)=>{let m=o.toNumber()+u;if(m>=t&&m<=i){let t=this.getPriceOfBinByBinId(e.binStep,m);d.push({binId:m,xAmount:s.amountX,yAmount:s.amountY,supply:s.liquiditySupply,price:t,version:r.version,pricePerToken:new h.Z(t).mul(new h.Z(10**(n-a))).toString()})}})}else[r,o].forEach(r=>{let[o]=ei(r.index);r.bins.forEach((s,u)=>{let m=o.toNumber()+u;if(m>=t&&m<=i){let t=this.getPriceOfBinByBinId(e.binStep,m);d.push({binId:m,xAmount:s.amountX,yAmount:s.amountY,supply:s.liquiditySupply,price:t,version:r.version,pricePerToken:new h.Z(t).mul(new h.Z(10**(n-a))).toString()})}})});return d}static getPriceOfBinByBinId(e,t){let i=new h.Z(e).div(new h.Z(1e4));return new h.Z(1).add(new h.Z(i)).pow(new h.Z(t)).toString()}processXYAmountDistribution(e){let t=null,i=[],n=[],a=[];return e.forEach(e=>{if(i.push(e.xAmountBpsOfTotal),n.push(e.yAmountBpsOfTotal),a.push(e.binId),t&&e.binId!==t+1)throw Error("Discontinuous Bin ID");t=e.binId}),{lowerBinId:e[0].binId,upperBinId:e[e.length-1].binId,xAmountDistribution:i,yAmountDistribution:n,binIds:a}}async getBins(e,t,i,n,a,r,o){let s=et(new m.BN(t)),u=et(new m.BN(i)),d=[];if(s.eq(u)){let[o]=H(e,s,this.program.programId),u=r??await this.program.account.binArray.fetch(o).catch(()=>{let[e,t]=ei(s),i=[];for(let n=e.toNumber();n<=t.toNumber();n++){let e=new m.BN(n);this.getPriceOfBinByBinId(e.toNumber()),i.push({amountX:new m.BN(0),amountY:new m.BN(0),liquiditySupply:new m.BN(0),rewardPerTokenStored:[new m.BN(0),new m.BN(0)],amountXIn:new m.BN(0),amountYIn:new m.BN(0),feeAmountXPerTokenStored:new m.BN(0),feeAmountYPerTokenStored:new m.BN(0),price:new m.BN(0)})}return{bins:i,index:s,version:1}}),[l]=ei(u.index);u.bins.forEach((e,r)=>{let o=l.toNumber()+r;if(o>=t&&o<=i){let t=this.getPriceOfBinByBinId(o);d.push({binId:o,xAmount:e.amountX,yAmount:e.amountY,supply:e.liquiditySupply,price:t,version:u.version,pricePerToken:new h.Z(t).mul(new h.Z(10**(n-a))).toString()})}})}else{let[m]=H(e,s,this.program.programId),[l]=H(e,u,this.program.programId);(await (async()=>r&&o?[r,o]:(await this.program.account.binArray.fetchMultiple([m,l])).filter(e=>null!==e))()).forEach(e=>{if(!e)return;let[r]=ei(e.index);e.bins.forEach((o,s)=>{let u=r.toNumber()+s;if(u>=t&&u<=i){let t=this.getPriceOfBinByBinId(u);d.push({binId:u,xAmount:o.amountX,yAmount:o.amountY,supply:o.liquiditySupply,price:t,version:e.version,pricePerToken:new h.Z(t).mul(new h.Z(10**(n-a))).toString()})}})})}return d}async binArraysToBeCreate(e,t){let i=Array.from({length:t.sub(e).toNumber()+1},(t,i)=>i+e.toNumber()).map(e=>new m.BN(e)),n=[];for(let e of i){let[t]=H(this.pubkey,e,this.program.programId);null===await this.program.provider.connection.getAccountInfo(t)&&n.push(t)}return n}async createBinArraysIfNeeded(e,t,i){let n=[];for(let a of Array.from({length:e.sub(t).toNumber()+1},(e,i)=>i+t.toNumber()).map(e=>new m.BN(e))){let[e]=H(this.pubkey,a,this.program.programId);null===await this.program.provider.connection.getAccountInfo(e)&&n.push(await this.program.methods.initializeBinArray(a).accounts({binArray:e,funder:i,lbPair:this.pubkey}).instruction())}return n}updateVolatilityAccumulator(e,t,i){let n=Math.abs(e.indexReference-i),a=e.volatilityReference+1e4*n;e.volatilityAccumulator=Math.min(a,t.maxVolatilityAccumulator)}updateReference(e,t,i,n){let a=n-t.lastUpdateTimestamp.toNumber();if(a>=i.filterPeriod){if(t.indexReference=e,a<i.decayPeriod){let e=Math.floor(t.volatilityAccumulator*i.reductionFactor/1e4);t.volatilityReference=e}else t.volatilityReference=0}}async createClaimBuildMethod({owner:e,position:t,shouldIncludePreIx:i=!0}){let n=et(new m.BN(t.positionData.lowerBinId)),[a]=H(this.pubkey,n,this.program.programId),r=n.add(new m.BN(1)),[o]=H(this.pubkey,r,this.program.programId),s=[];for(let n=0;n<2;n++){let r=this.lbPair.rewardInfos[n];if(!r||r.mint.equals(u.PublicKey.default))continue;let d=[],{ataPubKey:l,ix:c}=await eg(this.program.provider.connection,r.mint,e);c&&d.push(c);let p=await this.program.methods.claimReward(new m.BN(n)).accounts({lbPair:this.pubkey,sender:e,position:t.publicKey,binArrayLower:a,binArrayUpper:o,rewardVault:r.vault,rewardMint:r.mint,tokenProgram:y.H_,userTokenAccount:l}).preInstructions(i?d:[]).transaction();s.push(p)}return s}async createClaimSwapFeeMethod({owner:e,position:t,shouldIncludePretIx:i=!0,shouldIncludePostIx:n=!0}){let{lowerBinId:a,feeOwner:r}=t.positionData,o=et(new m.BN(a)),[s]=H(this.pubkey,o,this.program.programId),d=o.add(new m.BN(1)),[l]=H(this.pubkey,d,this.program.programId),[c]=$(this.tokenX.publicKey,this.pubkey,this.program.programId),[p]=$(this.tokenY.publicKey,this.pubkey,this.program.programId),g=r.equals(u.PublicKey.default)?e:r,h=[],[{ataPubKey:b,ix:w},{ataPubKey:f,ix:B}]=await Promise.all([eg(this.program.provider.connection,this.tokenX.publicKey,g,e),eg(this.program.provider.connection,this.tokenY.publicKey,g,e)]);w&&h.push(w),B&&h.push(B);let P=[];if([this.tokenX.publicKey.toBase58(),this.tokenY.publicKey.toBase58()].includes(y.Gd.toBase58())){let t=await eb(e);t&&P.push(t)}return await this.program.methods.claimFee().accounts({binArrayLower:s,binArrayUpper:l,lbPair:this.pubkey,sender:e,position:t.publicKey,reserveX:c,reserveY:p,tokenProgram:y.H_,tokenXMint:this.tokenX.publicKey,tokenYMint:this.tokenY.publicKey,userTokenX:b,userTokenY:f}).preInstructions(i?h:[]).postInstructions(n?P:[]).transaction()}},eP=eB}}]);
//# sourceMappingURL=eca8870b-bb7ac9156eeabe36.js.map